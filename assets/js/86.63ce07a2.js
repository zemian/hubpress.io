(window.webpackJsonp=window.webpackJsonp||[]).push([[86],{471:function(e,t,r){"use strict";r.r(t);var n=r(11),a=Object(n.a)({},(function(){var e=this,t=e.$createElement,r=e._self._c||t;return r("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[r("p",[e._v("I've found the "),r("a",{attrs:{href:"http://www.ruby-doc.org/core-1.9.3/String.html#method-i-succ",target:"_blank",rel:"noopener noreferrer"}},[e._v("Ruby's "),r("code",[e._v("String#next()")]),e._v(" or "),r("code",[e._v("#succ")]),r("OutboundLink")],1),e._v(" very useful and productive, specially when generating data for testing. Here is what the Ruby doc says:")]),e._v(" "),r("blockquote",[r("p",[e._v("succ -> new_str")]),e._v(" "),r("p",[e._v("next -> new_str")]),e._v(" "),r("p",[e._v("Returns the successor to str. The successor is calculated by incrementing characters starting from the rightmost alphanumeric (or the rightmost character > if there are no alphanumerics) in the string. Incrementing a digit always results in another digit, and incrementing a letter results in another letter > of the same case. Incrementing nonalphanumerics uses the underlying character sets collating sequence.")]),e._v(" "),r("p",[e._v("If the increment generates a carry, the character to the left of it is incremented. This process repeats until there is no carry, adding an additional > character if necessary.")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",[r("code",[e._v('"abcd".succ        #=> "abce"\n"THX1138".succ     #=> "THX1139"\n"<<koala>>".succ   #=> "<<koalb>>"\n"1999zzz".succ     #=> "2000aaa"\n"ZZZ9999".succ     #=> "AAAA0000"\n"***".succ         #=> "**+"\n')])])])]),e._v(" "),r("p",[e._v("So when I saw Groovy actually has provided a "),r("a",{attrs:{href:"http://groovy.codehaus.org/groovy-jdk/java/lang/String.html#next()",target:"_blank",rel:"noopener noreferrer"}},[e._v("String extension "),r("code",[e._v("#next()")]),r("OutboundLink")],1),e._v(" method, I was happy to try it out. But then I was quickly disappointed when the behavior is very different. The Groovy version is very simple and actually not very productive since it simply "),r("a",{attrs:{href:"https://github.com/groovy/groovy-core/blob/master/src/main/org/codehaus/groovy/runtime/StringGroovyMethods.java",target:"_blank",rel:"noopener noreferrer"}},[e._v("loop through Character set range in incrementally"),r("OutboundLink")],1),e._v(" (including non-printable characters blindly!). The Ruby's version, however, is much more productive since it produce visible characters. For examples:")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("    bash> ruby -e 'puts \"Z\".next()'\n    AA\n    bash> groovy -e 'println(\"Z\".next())'\n    [\n")])])]),r("p",[e._v("I wish Groovy version would improve in future as it's not very useful at the moment. Just for fun, I wrote a Java implementation version that mimics the Ruby's behavior:")]),e._v(" "),r("p",[e._v("And here is my unit test for sanity check:")])])}),[],!1,null,null,null);t.default=a.exports}}]);