<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <title>Zemian's Blog</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="">
    <meta name="author" content="">
    <meta name="keywords" content="">
    <meta name="generator" content="JBake">

    <!-- Le styles -->
    <link href="../css/bootstrap.min.css" rel="stylesheet">
    <link href="../css/asciidoctor.css" rel="stylesheet">
    <link href="../css/base.css" rel="stylesheet">
    <link href="../css/prettify.css" rel="stylesheet">

    <!-- HTML5 shim, for IE6-8 support of HTML5 elements -->
    <!--[if lt IE 9]>
      <script src="../js/html5shiv.min.js"></script>
    <![endif]-->

    <!-- Fav and touch icons -->
    <!--<link rel="apple-touch-icon-precomposed" sizes="144x144" href="../assets/ico/apple-touch-icon-144-precomposed.png">
    <link rel="apple-touch-icon-precomposed" sizes="114x114" href="../assets/ico/apple-touch-icon-114-precomposed.png">
    <link rel="apple-touch-icon-precomposed" sizes="72x72" href="../assets/ico/apple-touch-icon-72-precomposed.png">
    <link rel="apple-touch-icon-precomposed" href="../assets/ico/apple-touch-icon-57-precomposed.png">-->
    <link rel="shortcut icon" href="../favicon.ico">
  </head>
  <body onload="prettyPrint()">
    <div id="wrap">
	
	<!-- Fixed navbar -->
    <div class="navbar navbar-default navbar-fixed-top" role="navigation">
      <div class="container">
        <div class="navbar-header">
          <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <a class="navbar-brand" href="/index.html">Zemian's Blog</a>
        </div>
        <div class="navbar-collapse collapse">
          <ul class="nav navbar-nav">
            <li><a href="../index.html">Home</a></li>
            <li><a href="../about.html">About</a></li>
            <li><a href="../archive.html">Archive</a></li>
            <li><a href="..//tags">Tags</a></li>
          </ul>
        </div><!--/.nav-collapse -->
      </div>
    </div>
    <div class="container">
  			<a href="blog/2013/09/exploring-apache-camel-core-direct-component.html"><h1>Exploring Apache Camel Core - Direct Component</h1></a>
  			<p>07 September 2013, tags: 
			    <a href="../tags/camel.html">camel</a> 
  			</p>
  			<p><p>The Apache Camel allows you to create multiple <code>Route</code>'s within a single <code>CamelContext</code> space. The <code>direct</code> component in Camel would allow you to bridge messages between these <code>Route</code>'s. To demonstrate this, I will create few routes and pass messages between them.</p>
<pre><code>package camelcoredemo;

import org.slf4j.*;
import org.apache.camel.*;
import org.apache.camel.builder.*;
import org.apache.camel.main.Main;
import java.io.*;

public class DirectDemoCamel extends Main {
    static Logger LOG = LoggerFactory.getLogger(DirectDemoCamel.class);
    public static void main(String[] args) throws Exception {
        DirectDemoCamel main = new DirectDemoCamel();
        main.enableHangupSupport();
        main.addRouteBuilder(createRouteBuilder1());
        main.addRouteBuilder(createRouteBuilder2());
        main.addRouteBuilder(createRouteBuilder3());
        main.run(args);
    }
    // The file poller route
    static RouteBuilder createRouteBuilder1() {
        return new RouteBuilder() {
            public void configure() {
                from(&quot;file://target/input?preMove=staging&amp;move=.processed&quot;)
                .process(new Processor() {
                    public void process(Exchange msg) {
                        CamelContext camelContext = msg.getContext();
                        ProducerTemplate producer = camelContext.createProducerTemplate();
                        File file = msg.getIn().getBody(File.class);
                        boolean specialFile = file.getName().endsWith(&quot;_SPECIAL.dat&quot;);
                        if (specialFile)
                            producer.send(&quot;direct:specialRoute&quot;, msg);
                        else
                            producer.send(&quot;direct:normalRoute&quot;, msg);
                    }
                });
            }
        };
    }
    // The special file processing route
    static RouteBuilder createRouteBuilder2() {
        return new RouteBuilder() {
            public void configure() {
                from(&quot;direct:specialRoute&quot;)
                .process(new Processor() {
                    public void process(Exchange msg) {
                        LOG.info(&quot;Processing special file: &quot; + msg);
                    }
                });
            }
        };
    }
    // The normal file processing route
    static RouteBuilder createRouteBuilder3() {
        return new RouteBuilder() {
            public void configure() {
                from(&quot;direct:normalRoute&quot;)
                .process(new Processor() {
                    public void process(Exchange msg) {
                        LOG.info(&quot;Processing normal file: &quot; + msg);
                    }
                });
            }
        };
    }
}
</code></pre>
<p>Here I have created 3 <code>Route</code>'s and re-used the <code>file</code> component I have introduced in the past. The first <code>Route</code> polls a directory, and then based on the name of the file found, we send it to either to <strong>special</strong> or <strong>normal</strong><code>Route</code> for processing. Because these <code>Route</code>'s are separated, we need a bridge channel to pass the messages through, hence it's what the <code>direct</code> component does. The usage is simply use any <strong>unique name</strong> within the <code>CamelContext</code>, and it will serve as a direct memory queue to pass messages. You may read from or send to these queues. So as you can see, the <code>direct</code> component let you easily breakup a complex route workflow into smaller part.</p>
<p>In above demo, I have also introduced a bit of Camel core features: <code>ProducerTemplate</code>. Within a <code>CamelContext</code> you may create an instance of <code>ProducerTemplate</code> and it will allow you to send any messages to any endpoints dynamically at runtime. Usually you would probably want to store this producer object as member field instead of per each message processing. But for demo purpose, I will leave it as simple as that, and leave you as exercise to explore more on your own.</p>
<p>There are more options availabe from <a href="http://camel.apache.org/direct.html">Direct</a> component<br />
that you may explore.<br />
<a href="http://saltnlight5.blogspot.com/2013/08/getting-started-with-apache-camel-using.html">Try it out with a Route</a><br />
and see it for yourself.</p>
</p>
  			<a href="blog/2013/09/exploring-apache-camel-core-file-component.html"><h1>Exploring Apache Camel Core - File Component</h1></a>
  			<p>04 September 2013, tags: 
			    <a href="../tags/camel.html">camel</a> 
  			</p>
  			<p><p>A file poller is a very useful mechanism to solve common IT problems. Camel’s built-in <code>file</code> component is extremely flexible, and there are many options available for configuration. Let’s cover few common usages here.</p>
<h2>Polling a directory for input files</h2>
<p>Here is a typical Camel <code>Route</code> used to poll a directory for input files on every second.</p>
<pre><code>import org.slf4j.*;
import org.apache.camel.*;
import org.apache.camel.builder.*;
import java.io.*;

public class FileRouteBuilder extends RouteBuilder {
    static Logger LOG = LoggerFactory.getLogger(FileRouteBuilder.class);
    public void configure() {
        from(&quot;file://target/input?delay=1000&quot;)
        .process(new Processor() {
            public void process(Exchange msg) {
                File file = msg.getIn().getBody(File.class);
                LOG.info(&quot;Processing file: &quot; + file);
            }
        });
    }
}
</code></pre>
<p>Run this with following</p>
<pre><code>mvn compile exec:java -Dexec.mainClass=org.apache.camel.main.Main -Dexec.args='-r camelcoredemo.FileRouteBuilder'
</code></pre>
<p>The program will begin to poll your <code>target/input</code> folder under your current directory, and wait for incoming files. To test with input files, you would need to open another terminal, and then create some files as follow.</p>
<pre><code>echo 'Hello 1' &gt; target/input/test1.txt
echo 'Hello 2' &gt; target/input/test2.txt
</code></pre>
<p>You should now see the first prompt window start to picking up the files and pass to the next <code>Processor</code> step. In the <code>Processor</code>, we obtain the <code>File</code> object from the message body. It then simply logs it’s file name. You may hit <code>CTRL+C</code> when you are done.</p>
<p>There many configurable options from <code>file</code> componet you may use in the URL, but most of the default settings are enough to get you going as simple case above. Some of these default behavior is such that if the input folder doesn’t exists, it will create it. And when the file is done processing by the <code>Route</code>, it will be moved into a <code>.camel</code> folder. If you don’t want the file at all after processing, then set <code>delete=true</code> in the URL.</p>
<h2>Read in the file content and converting to different types</h2>
<p>By default, the <code>file</code> component will create a <code>org.apache.camel.component.file.GenericFile</code> object for each file found and pass it down your <code>Route</code> as message body. You may retrieve all your file information through this object. Or alternatively, you may also use the <code>Exchange</code> API to auto convert the message body object to a type you expect to receive (eg: as with <code>msg.getIn().getBody(File.class)</code>). In above example, the <code>File</code> is a type you expect to get from the message body, and Camel hence will try to convert it for you. The Camel uses the context’s registry space to pre-registered many <code>TypeConverter</code>'s that can handle most of the common data types (like Java primative etc) conversion. These <code>TypeConverter</code><em>s</em> are powerful way to make your <code>Route</code> and <code>Processor</code> more flexbile and portable.</p>
<p>Camel will not only convert just your <code>File</code> object from message body, but it can also read the file content. If your files are character text based, then you can simply do this.</p>
<pre><code>        from(&quot;file://target/input?charset=UTF-8&quot;)
        .process(new Processor() {
            public void process(Exchange msg) {
                String text = msg.getIn().getBody(String.class);
                LOG.info(&quot;Processing text: &quot; + text);
            }
        });
</code></pre>
<p>That’s it! Simply specify <code>String</code> type, and Camel will read your file in and pass the entire file text content as body message. You may even use the <code>charset</code> to change the encoding.</p>
<p>If you are dealing with binary file, then simply try <code>byte[] bytes = msg.getIn().getBody(byte[].class);</code> conversion instead. Pretty cool huh?</p>
<h2>Polling and processing large files</h2>
<p>When working with large files, there few options in <code>file</code> componet that you might want to use to ensure proper handling. For example, you might want to move the input file into a <code>staging</code> folder before the <code>Route</code> starts the processing; and when it’s done, move it to a <code>.completed</code> folder.</p>
<pre><code>        from(&quot;file://target/input?preMove=staging&amp;move=.completed&quot;)
        .process(new Processor() {
            public void process(Exchange msg) {
                File file = msg.getIn().getBody(File.class);
                LOG.info(&quot;Processing file: &quot; + file);
            }
        });
</code></pre>
<p>To feed input files properly into the polling folder, it’s best if the sender generates the input files in a temporary folder first, and only when it’s ready then move it into the polling folder. This will minimize reading an incomplete file by the <code>Route</code> if the input file might take times to generate. Also another solution to this is to config <code>file</code> endpoint to only read the polling folder when there is a signal or ready marker file exists. For example:</p>
<pre><code>        from(&quot;file://target/input?preMove=staging&amp;move=.completed&amp;doneFileName=ReadyFile.txt&quot;)
        .process(new Processor() {
            public void process(Exchange msg) {
                File file = msg.getIn().getBody(File.class);
                LOG.info(&quot;Processing file: &quot; + file);
            }
        });
</code></pre>
<p>Above will only read the <code>target/input</code> folder when there is a <code>ReadyFile.txt</code> file exists. The marker file can be just an empty file, and it will be removed by Camel after polling. This solution would allow the sender to generate input files in however long time it might take.</p>
<p>Another concern with large file processing is to avoid loading entire file content into memory for processing. To be more practical, you want to split the file into records (eg: per line) and process it one by one (or called &quot;streaming&quot;). Here is how you would do that using Camel.</p>
<pre><code>        from(&quot;file://target/input?preMove=staging&amp;move=.completed&quot;)
        .split(body().tokenize(&quot;\n&quot;))
        .streaming()
        .process(new Processor() {
            public void process(Exchange msg) {
                String line = msg.getIn().getBody(String.class);
                LOG.info(&quot;Processing line: &quot; + line);
            }
        });
</code></pre>
<p>This <code>Route</code> will allow you to process large size file without cosuming too much memory and process it line by line very efficiently.</p>
<h2>Writing messages back into file</h2>
<p>The <code>file</code> component can also be used to write messages into files. Recall that we may use <code>dataset</code> component to generate sample messages. We will use that to feed the <code>Route</code> and send to the <code>file</code> component so you can see that each message generated will be saved into a file.</p>
<pre><code>package camelcoredemo;

import org.slf4j.*;
import org.apache.camel.*;
import org.apache.camel.builder.*;
import org.apache.camel.main.Main;
import org.apache.camel.component.dataset.*;

public class FileDemoCamel extends Main {
    static Logger LOG = LoggerFactory.getLogger(FileDemoCamel.class);
    public static void main(String[] args) throws Exception {
        FileDemoCamel main = new FileDemoCamel();
        main.enableHangupSupport();
        main.addRouteBuilder(createRouteBuilder());
        main.bind(&quot;sampleGenerator&quot;, createDataSet());
        main.run(args);
    }
    static RouteBuilder createRouteBuilder() {
        return new RouteBuilder() {
            public void configure() {
                from(&quot;dataset://sampleGenerator&quot;)
                .to(&quot;file://target/output&quot;);
            }
        };
    }
    static DataSet createDataSet() {
        return new SimpleDataSet();
    }
}
</code></pre>
<p>Compile and run it</p>
<pre><code>mvn compile exec:java -Dexec.mainClass=camelcoredemo.FileDemoCamel
</code></pre>
<p>Upon complete you will see that 10 files would be generated in <code>target/output</code> folder with<br />
file name in <code>ID-&lt;hostname&gt;-&lt;unique-number&gt;-&lt;msg-seq-num&gt;</code> format.</p>
<p>There are more options availabe from <a href="http://camel.apache.org/file2.html">File</a> component<br />
that you may explore.<br />
<a href="http://saltnlight5.blogspot.com/2013/08/getting-started-with-apache-camel-using.html">Try it out with a Route</a><br />
and see it for yourself.</p>
</p>
  			<a href="blog/2013/09/exploring-apache-camel-core-dataset-component.html"><h1>Exploring Apache Camel Core - DataSet Component</h1></a>
  			<p>03 September 2013, tags: 
			    <a href="../tags/camel.html">camel</a> 
  			</p>
  			<p><p>A good sample data generator can help you test program more throughly and help measure<br />
the processing throughput. The <code>camel-core</code> comes with a <code>dataset</code> component that can<br />
help you do this easily. All you need is to provide a bean that implements<br />
<code>org.apache.camel.component.dataset.DataSet</code> interface and bind it in<br />
CamelContext registry. Here is an example:</p>
<pre><code>package camelcoredemo;

import org.slf4j.*;
import org.apache.camel.*;
import org.apache.camel.builder.*;
import org.apache.camel.main.Main;
import org.apache.camel.component.dataset.*;

public class DataSetDemoCamel extends Main {
    static Logger LOG = LoggerFactory.getLogger(DataSetDemoCamel.class);
    public static void main(String[] args) throws Exception {
        DataSetDemoCamel main = new DataSetDemoCamel();
        main.enableHangupSupport();
        main.addRouteBuilder(createRouteBuilder());
        main.bind(&quot;sampleGenerator&quot;, createDataSet());
        main.run(args);
    }
    static RouteBuilder createRouteBuilder() {
        return new RouteBuilder() {
            public void configure() {
                from(&quot;dataset://sampleGenerator&quot;)
                .to(&quot;log://demo&quot;);
            }
        };
    }
    static DataSet createDataSet() {
        return new SimpleDataSet();
    }
}
</code></pre>
<p>Compile and run it.</p>
<pre><code>mvn compile exec:java -Dexec.mainClass=camelcoredemo.DataSetDemoCamel
</code></pre>
<p>In here we have used the built-in <code>org.apache.camel.component.dataset.SimpleDataSet</code><br />
implementation, which by default will generate 10 messages with a text body set<br />
to <code>&lt;hello&gt;world!&lt;/hello&gt;</code>. You may easily change the value, or even provide your own<br />
implementation starting with <code>org.apache.camel.component.dataset.DataSetSupport</code> base<br />
class to customize your data set.</p>
<h2>Use DataSet Component to measure throughput</h2>
<p>One useful feature of <code>dataset</code> component I found is using it to load test your <code>Route</code>.<br />
To do this, you have to adjust couple settings though. Let’s say if I want to load<br />
a large text file as sample input data and feed it to the <code>Route</code>, and then measure its<br />
throughout.</p>
<pre><code>    static RouteBuilder createRouteBuilder() {
        return new RouteBuilder() {
            public void configure() {
                from(&quot;dataset://sampleGenerator?produceDelay=0&quot;)
                .to(&quot;log://demo?groupSize=100&quot;);
            }
        };
    }
    static DataSet createDataSet() {
        SimpleDataSet result = new SimpleDataSet();
        result.setSize(500);
        result.setDefaultBody(readFileToString(&quot;my-large-sample.txt&quot;);
        return result;
    }
</code></pre>
<p>Replace above in the <code>Main</code> class and you will notice that it will pump 500 messages<br />
into the <code>Route</code>, and it samples every 100 messages and display its throught rates. I<br />
have to add <code>produceDelay=0</code> option so the generator so it will not pause between messages.<br />
Then I have added <code>groupSize=100</code> option to <code>log</code> component for throughput measurement.<br />
I skipped <code>readFileToString(String)</code> demo code since I assume you can easily figured that<br />
out on your own. (Hint: checkout Apache <code>commons-io</code> library.)</p>
<p>There is another side of <code>dataset</code> component that you may use, and that is to receive and<br />
verify message content. You would simply use the same URL in a<br />
<code>to(url)</code> line. Internally Camel would assert your message body against your original.</p>
<p>There are more options availabe from <a href="http://camel.apache.org/dataset.html">DataSet</a> component<br />
that you may explore.<br />
<a href="http://saltnlight5.blogspot.com/2013/08/getting-started-with-apache-camel-using.html">Try it out with a Route</a><br />
and see it for yourself.</p>
</p>
  			<a href="blog/2013/09/exploring-apache-camel-core-log-component.html"><h1>Exploring Apache Camel Core - Log Component</h1></a>
  			<p>02 September 2013, tags: 
			    <a href="../tags/camel.html">camel</a> 
  			</p>
  			<p><p>There are many ways to log and inspect the messages as it pass through your<br />
Camel <code>Route</code>. The <code>camel-core</code> comes with a <code>log</code> component that let<br />
you inspect the message. So instead of write a separate<br />
<code>Processor</code> just to log a line as got processed, try using this:</p>
<pre><code>from(&quot;timer://timer1?period=1s&quot;)
.to(&quot;log:demo&quot;)
</code></pre>
<p>By default, the <code>log</code> component will record your message body content<br />
through your logger name, <code>demo</code> in above case, at INFO level. Since you can give any<br />
name, you can control the logging LEVEL anyway you like through a Camel<br />
<a href="http://saltnlight5.blogspot.com/2013/08/how-to-configure-slf4j-with-different.html">SLF4J logger implementation</a>.</p>
<p>To log the message in DEBUG level, try this</p>
<pre><code>from(&quot;timer://timer1?period=1s&quot;)
.to(&quot;log:demo?level=DEBUG&quot;)
</code></pre>
<p>Now if you use <code>log4j</code> as logger implementation, then ensure to add a<br />
logger config like this.</p>
<pre><code>log4j.logger.demo = DEBUG
log4j.logger.org.apache.camel = INFO
</code></pre>
<p>The Camel message may have Properties and Headers as well, so to display<br />
these, you may add <code>showAll=true</code>.</p>
<p>When you process messages that have large body text, it might be more<br />
practical to just dislay certain number of characters. To do this, add<br />
<code>maxChars=256</code> to URL.</p>
<h2>How to measure Camel messages throughput rate</h2>
<p>One of the hidden gem of the <code>log</code> componet is its ability to log messages<br />
throughput! You may specific group of messages to be logged, and once it<br />
reached that count, it will print the msgs/sec rate output. To enable<br />
this, just add <code>groupSize</code> option to URL.</p>
<p>To demo this, I will create a <code>SampleGenerator</code> bean processor<br />
that would flood the <code>Route</code> with sample messages. I will use the Camel<br />
context registry to bind the bean, and then reference it in the <code>Route</code>. Here<br />
is the demo code.</p>
<pre><code>package camelcoredemo;

import org.slf4j.*;
import org.apache.camel.*;
import org.apache.camel.builder.*;
import org.apache.camel.main.Main;

public class LogDemoCamel extends Main {
    static Logger LOG = LoggerFactory.getLogger(LogDemoCamel.class);
    public static void main(String[] args) throws Exception {
        LogDemoCamel main = new LogDemoCamel();
        main.enableHangupSupport();
        main.addRouteBuilder(createRouteBuilder());
        main.bind(&quot;sampleGenerator&quot;, new SampleGenerator());
        main.run(args);
    }
    static RouteBuilder createRouteBuilder() {
        return new RouteBuilder() {
            public void configure() {
                from(&quot;bean:sampleGenerator&quot;)
                .to(&quot;log://demo?groupSize=100&quot;);
            }
        };
    }
    static class SampleGenerator implements Processor{
        int count = 0;
        public void process(Exchange msg) throws Exception {
            if (count &gt;= 500){
                LOG.info(&quot;Max count has reached. Do nothing.&quot;);
                Thread.sleep(Long.MAX_VALUE);
                return;
            }

            // Let's generate sample message.
            count++;
            LOG.trace(&quot;Generating sample msg #{}&quot;, count);
            msg.getOut().setBody(&quot;Sample msg&quot;);
        }
    }
}
</code></pre>
<p>Now you should able to compile and run this demo.</p>
<pre><code>mvn compile exec:java -Dexec.mainClass=camelcoredemo.LogDemoCamel
</code></pre>
<p>When running this demo, you will notice the rate will be displayed on console<br />
and how fast you can pump message to <code>Route</code> and to process it. This is a<br />
very useful feature to help you measure and have a quick view on your <code>Route</code>'s<br />
capability.</p>
<p>There are more options availabe from <a href="http://camel.apache.org/log.html">Log</a> component<br />
that you may explore.<br />
<a href="http://saltnlight5.blogspot.com/2013/08/getting-started-with-apache-camel-using.html">Try it out with a Route</a><br />
and see it for yourself.</p>
</p>
  			<a href="blog/2013/09/exploring-apache-camel-core-timer-component.html"><h1>Exploring Apache Camel Core - Timer Component</h1></a>
  			<p>01 September 2013, tags: 
			    <a href="../tags/camel.html">camel</a> 
  			</p>
  			<p><p>Camel Timer is a simple and yet useful component.<br />
It brings the JDK’s timer functionality into your camel Route with very simple config.</p>
<pre><code>   from(&quot;timer://mytimer?period=1000&quot;)
    .process(new Processor() {
        public void process(Exchange msg) {
            LOG.info(&quot;Processing {}&quot;, msg);
        }
    });
</code></pre>
<p>That will generate a timer event message every second. You may short hand <code>1000</code> with<br />
<code>1s</code> instead. It supports <code>m</code> for minutes, or <code>h</code> for hours as well. Pretty handy.</p>
<p>Another useful timer feature is that it can limit (stop) the number of timer messages after a certain<br />
count. You simply need to add <code>repeatCount</code> option toward the url.</p>
<p>Couple of properties from the event message would be useful when handling the timer<br />
message. Here is an example how to read them.</p>
<pre><code>   from(&quot;timer://mytimer?period=1s&amp;repeatCount=5&quot;)
    .process(new Processor() {
        public void process(Exchange msg) {
            java.util.Date fireTime = msg.getProperty(Exchange.TIMER_FIRED_TIME, java.util.Date.class);
            int eventCount = msg.getProperty(Exchange.TIMER_COUNTER, Integer.class);
            LOG.info(&quot;We received {}th timer event that was fired on {}&quot;, eventCount, fireTime);
        }
    });
</code></pre>
<p>There are more options availabe from <a href="http://camel.apache.org/timer.html">Timer</a> component<br />
that you may explore.<br />
<a href="http://saltnlight5.blogspot.com/2013/08/getting-started-with-apache-camel-using.html">Try it out with a Route</a><br />
and see it for yourself.</p>
</p>
  			<a href="blog/2013/08/running-maven-war-packaging-project-without-pom-config.html"><h1>Running Maven war packaging project without pom config</h1></a>
  			<p>27 August 2013, tags: 
			    <a href="../tags/maven.html">maven</a> 
  			</p>
  			<p><p>Use Jetty (latest 9.x requires JDK7)</p>
<pre><code>bash&gt; mvn org.eclipse.jetty:jetty-maven-plugin:run -Djetty.port=8081
</code></pre>
<p>Or use Jetty on JDK 6</p>
<pre><code>bash&gt; mvn org.mortbay.jetty:jetty-maven-plugin:8.1.12.v20130726:run -Djetty.port=8081
</code></pre>
<p>Or use Tomcat</p>
<pre><code>bash&gt; mvn org.apache.tomcat.maven:tomcat7-maven-plugin:run -Dmaven.tomcat.port=8081
</code></pre>
</p>
  			<a href="blog/2013/08/how-to-create-web-app-with-quartz-scheduler-and-logging.html"><h1>How to create web-app with Quartz Scheduler and logging</h1></a>
  			<p>25 August 2013, tags: 
			    <a href="../tags/quartz.html">quartz</a> 
  			</p>
  			<p><p>I sometimes help out users in Quartz Scheduler forums. Once in a while some one would<br />
ask how can he/she setup the Quartz inside a web application. This is actualy a fairly<br />
simple thing to do. The library already comes with a <code>ServletContextListener</code> that<br />
you can use to start a Scheduler. I will show you a simple webapp example here.</p>
<p>First create a Maven <code>pom.xml</code> file.</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xsi:schemaLocation=
        &quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd&quot;&gt;

    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;groupId&gt;quartz-web-demo&lt;/groupId&gt;
    &lt;artifactId&gt;quartz-web-demo&lt;/artifactId&gt;
    &lt;packaging&gt;war&lt;/packaging&gt;
    &lt;version&gt;1.0-SANPSHOT&lt;/version&gt;

    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.quartz-scheduler&lt;/groupId&gt;
            &lt;artifactId&gt;quartz&lt;/artifactId&gt;
            &lt;version&gt;2.2.0&lt;/version&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;

&lt;/project&gt;
</code></pre>
<p>Then you need to create a <code>src/main/webapp/META-INF/web.xml</code> file.</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
 &lt;web-app version=&quot;2.5&quot;
    xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xsi:schemaLocation=
        &quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd&quot;&gt;

     &lt;context-param&gt;
         &lt;param-name&gt;quartz:config-file&lt;/param-name&gt;
         &lt;param-value&gt;quartz.properties&lt;/param-value&gt;
     &lt;/context-param&gt;
     &lt;context-param&gt;
         &lt;param-name&gt;quartz:shutdown-on-unload&lt;/param-name&gt;
         &lt;param-value&gt;true&lt;/param-value&gt;
     &lt;/context-param&gt;
     &lt;context-param&gt;
         &lt;param-name&gt;quartz:wait-on-shutdown&lt;/param-name&gt;
         &lt;param-value&gt;true&lt;/param-value&gt;
     &lt;/context-param&gt;
     &lt;context-param&gt;
         &lt;param-name&gt;quartz:start-on-load&lt;/param-name&gt;
         &lt;param-value&gt;true&lt;/param-value&gt;
     &lt;/context-param&gt;

     &lt;listener&gt;
         &lt;listener-class&gt;org.quartz.ee.servlet.QuartzInitializerListener&lt;/listener-class&gt;
     &lt;/listener&gt;

 &lt;/web-app&gt;
</code></pre>
<p>And lastly, you need a <code>src/main/resources/quartz.properties</code> config file for Scheduler.</p>
<pre><code># Main Quartz configuration
org.quartz.scheduler.skipUpdateCheck = true
org.quartz.scheduler.instanceName = MyQuartzScheduler
org.quartz.scheduler.jobFactory.class = org.quartz.simpl.SimpleJobFactory
org.quartz.threadPool.class = org.quartz.simpl.SimpleThreadPool
org.quartz.threadPool.threadCount = 5
</code></pre>
<p>You may configure<br />
<a href="http://quartz-scheduler.org/documentation/quartz-2.2.x/configuration/">many other things</a> with Quartz,<br />
but above should get you started as in In-Memory scheduler.</p>
<p>Now you should able to compile and run it.</p>
<pre><code>bash&gt; mvn compile
bash&gt; mvn org.apache.tomcat.maven:tomcat7-maven-plugin:2.1:run -Dmaven.tomcat.port=8081
</code></pre>
<h2>How to configure logging for Quartz Scheduler</h2>
<p>Another frequently asked question is how do they setup logging and see the DEBUG level<br />
messages. The Quartz Schedulers uses SLF4J, so you have many<br />
<a href="http://saltnlight5.blogspot.com/2013/08/how-to-configure-slf4j-with-different.html">loggers options</a><br />
to choose. I will show you how to setup Log4j for example below.</p>
<p>First, add this to your <code>pom.xml</code></p>
<pre><code>        &lt;dependency&gt;
            &lt;groupId&gt;org.slf4j&lt;/groupId&gt;
            &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;
            &lt;version&gt;1.7.5&lt;/version&gt;
        &lt;/dependency&gt;
</code></pre>
<p>Then add <code>src/main/resources/log4j.properties</code> file to show messages onto STDOUT.</p>
<pre><code>log4j.rootLogger=INFO, stdout
log4j.logger.org.quartz=DEBUG
log4j.appender.stdout=org.apache.log4j.ConsoleAppender
log4j.appender.stdout.layout=org.apache.log4j.PatternLayout
log4j.appender.stdout.layout.ConversionPattern=%5p [%t] (%F:%L) - %m%n
</code></pre>
<p>Restart your web application on command line, and now you should see all the DEBUG<br />
level logging messages coming from Quartz library.</p>
<p>With everything running, your next question might be asking how do you access the scheduler<br />
from your web application? Well, when the scheduler is created by the servlet context listener,<br />
it is stored inside the web app’s ServletContext space with<br />
<code>org.quartz.impl.StdSchedulerFactory.KEY</code> key. So you may retrieve it and use it in your<br />
own Servlet like this:</p>
<pre><code>public class YourServlet extends HttpServlet {
    public init(ServletConfig cfg) {
        String key = &quot;org.quartz.impl.StdSchedulerFactory.KEY&quot;;
        ServletContext servletContext = cfg.getServletContext();
        StdSchedulerFactory factory = (StdSchedulerFactory) servletContext.getAttribute(key);
        Scheduler quartzScheduler = factory.getScheduler(&quot;MyQuartzScheduler&quot;);
        // TODO use quartzScheduler here.
    }
}
</code></pre>
<p>Now you are on your way to build your next scheduling application!</p>
<p>Have fun!</p>
</p>
  			<a href="blog/2013/08/myschedule-3-2-1-0-is-out.html"><h1>MySchedule-3.2.1.0 is out!</h1></a>
  			<p>23 August 2013, tags: 
			    <a href="../tags/myschedule.html">myschedule</a> 
  			</p>
  			<p><p>The main work on this release is upgrade to Quartz 2.2.1</p>
<ul>
<li>Upgraded to Quartz 2.2.1
<ul>
<li>
<p>Upgraded to SLF4J 1.7.5</p>
</li>
<li>
<p>Quartz 2.2.1 API has some changes that break backward compatibility and this release addressed these<br />
issues:</p>
</li>
</ul>
<p>-- SchedulerPlugin interface now has different #initialize() signature<br />
-- SchedulerListener interface has added new method #schedulerStarting()<br />
-- Scheduler interface has couple new methods addJobs and schedulerJobs with Set instead of List.</p>
</li>
</ul>
<p>Get it here: <a href="https://code.google.com/p/myschedule/downloads/list">https://code.google.com/p/myschedule/downloads/list</a></p>
</p>
  			<a href="blog/2013/08/getting-started-with-apache-camel-using-java.html"><h1>Getting started with Apache Camel using Java</h1></a>
  			<p>20 August 2013, tags: 
			    <a href="../tags/camel.html">camel</a> 
  			</p>
  			<p><p>Apache Camel is a very useful library that helps you process events or messages<br />
from many different sources. You may move these messages through many different<br />
protocols such as between VM, HTTP, FTP, JMS, or even DIRECTORY/FILE, and yet<br />
still keep your processing code free of transport logic. This allows you to<br />
concentrate on digesting the content of the messages instead.</p>
<p>Here I will provide a tutorial on how you can get started with Apache Camel using<br />
Java.</p>
<p>Let’s start by creating a Maven project <code>pom.xml</code> file first.</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xsi:schemaLocation=&quot;
        http://maven.apache.org/POM/4.0.0
        http://maven.apache.org/maven-v4_0_0.xsd&quot;&gt;

    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
    &lt;groupId&gt;camel-spring-demo&lt;/groupId&gt;
    &lt;artifactId&gt;camel-spring-demo&lt;/artifactId&gt;
    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;packaging&gt;jar&lt;/packaging&gt;

    &lt;properties&gt;
        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
        &lt;camel.version&gt;2.11.1&lt;/camel.version&gt;
    &lt;/properties&gt;

    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.apache.camel&lt;/groupId&gt;
            &lt;artifactId&gt;camel-core&lt;/artifactId&gt;
            &lt;version&gt;${camel.version}&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.slf4j&lt;/groupId&gt;
            &lt;artifactId&gt;slf4j-simple&lt;/artifactId&gt;
            &lt;version&gt;1.7.5&lt;/version&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;

&lt;/project&gt;
</code></pre>
<p>We are only going to explore the <code>camel-core</code>, which actually contains quite of few useful<br />
components that you may use. Also for logging purpose, I have added a <code>slf4j-simple</code> as<br />
<a href="http://saltnlight5.blogspot.com/2013/08/how-to-configure-slf4j-with-different.html">a logger implementation</a><br />
so we may see output on console.</p>
<p>Next you just need a class to construct an <code>Route</code>. A <code>Route</code> is like a instruction<br />
definition to Camel on how to move your messages from one point to another. We are<br />
going to create <code>src/main/java/camelcoredemo/TimerRouteBuilder.java</code> file that<br />
will generate a timer message on every second, and then pass to a processor<br />
that simply logs it.</p>
<pre><code>package camelcoredemo;

import org.slf4j.*;
import org.apache.camel.*;
import org.apache.camel.builder.*;

public class TimerRouteBuilder extends RouteBuilder {
    static Logger LOG = LoggerFactory.getLogger(TimerRouteBuilder.class);
    public void configure() {
        from(&quot;timer://timer1?period=1000&quot;)
        .process(new Processor() {
            public void process(Exchange msg) {
                LOG.info(&quot;Processing {}&quot;, msg);
            }
        });
    }
}
</code></pre>
<p>That’s all you needed to get started. Now you may build and run this simple<br />
demo.</p>
<pre><code>bash&gt; mvn compile
bash&gt; mvn exec:java -Dexec.mainClass=org.apache.camel.main.Main -Dexec.args='-r camelcoredemo.TimerRouteBuilder'
</code></pre>
<p>Notice that we didn’t even write a Java <strong>main</strong> class, but simply use the<br />
<code>org.apache.camel.main.Main</code> option to accepts a <code>RouteBuilder</code> class<br />
name as parameter. Then it will load and create the route automatically.</p>
<h2>Controlling the <code>CamelContext</code></h2>
<p>When you start Camel, it creates a <code>CamelContext</code> object that holds<br />
many information on how to run it, including the definition of the<br />
<code>Route</code> we created. Now if you want to have more control over this<br />
<code>CamelContext</code>, then you would need to write your own <code>Main</code> class.<br />
I will show you a simple one here.</p>
<pre><code>package camelcoredemo;

import org.slf4j.*;
import org.apache.camel.*;
import org.apache.camel.impl.*;
import org.apache.camel.builder.*;

public class TimerMain {
    static Logger LOG = LoggerFactory.getLogger(TimerMain.class);
    public static void main(String[] args) throws Exception {
        new TimerMain().run();
    }
    void run() throws Exception {
        final CamelContext camelContext = new DefaultCamelContext();
        camelContext.addRoutes(createRouteBuilder());
        camelContext.setTracing(true);
        camelContext.start();

        Runtime.getRuntime().addShutdownHook(new Thread() {
            public void run() {
                try {
                    camelContext.stop();
                } catch (Exception e) {
                    throw new RuntimeException(e);
                }
            }
        });

        waitForStop();
    }
    RouteBuilder createRouteBuilder() {
        return new TimerRouteBuilder();
    }
    void waitForStop() {
        while (true) {
            try {
                Thread.sleep(Long.MAX_VALUE);
            } catch (InterruptedException e) {
                break;
            }
        }
    }
}
</code></pre>
<p>As you can see, we re-used the existing <code>TimerRouteBuilder</code> class inside<br />
<code>createRouteBuilder()</code> method. Our <code>Main</code> class now have full control<br />
when to create, start and stop the<br />
<a href="http://camel.apache.org/maven/current/camel-core/apidocs/org/apache/camel/CamelContext.html"><code>CamelContext</code></a>.<br />
This context allow you to have control on how to configure Camel<br />
globally rather than on <code>Route</code> level. The javadoc link gives all the setter<br />
methods that you can explore on what it can do.</p>
<p>Noticed that we also need to provide few setup codes in our <code>Main</code> class.<br />
First we need to handle graceful shutdown, so we added a Java shutdown hook<br />
to invoke the context <code>stop()</code>. Secondly we need to add a thread block after<br />
context has started. The reason for this is that the <code>CamelContext#start()</code><br />
method is non-blocking! If you don’t block your <code>Main</code> thread after<br />
start, then it will simply exit right after it, which will have not<br />
much use. You want to run Camel as a service (like a server) until<br />
you explicitly press <code>CTRL+C</code> to terminate the process.</p>
<h2>Improving the <code>Main</code> class to start <code>CamelContext</code></h2>
<p>If you don’t want to deal with much of the <code>Main</code> class setup<br />
code such as above, then you may simply extends the <code>org.apache.camel.main.Main</code><br />
class provided by <code>camel-core</code> intead. By piggy-back on this class, you will<br />
only not have your Context auto setup, but you will get all the additional<br />
command line features such as controlling how long to run the<br />
process for, enabling tracing, loading custom route class etc.</p>
<p>Refactoring previous example, here is how it look like.</p>
<pre><code>package camelcoredemo;

import org.slf4j.*;
import org.apache.camel.builder.*;
import org.apache.camel.main.Main;

public class TimerMain2 extends Main {
    static Logger LOG = LoggerFactory.getLogger(TimerMain2.class);
    public static void main(String[] args) throws Exception {
        TimerMain2 main = new TimerMain2();
        main.enableHangupSupport();
        main.addRouteBuilder(createRouteBuilder());
        main.run(args);
    }
    static RouteBuilder createRouteBuilder() {
        return new TimerRouteBuilder();
    }
}
</code></pre>
<p>Now our <code>TimerMain2</code> is much shorter, and you may try it out and it should<br />
function the same as before.</p>
<pre><code>bash&gt; mvn compile
bash&gt; mvn exec:java -Dexec.mainClass=camelcoredemo.TimerMain2 -Dexec.args='-t'
</code></pre>
<p>Notice that we have given <code>-t</code> option and it will dump <code>Route</code> tracing. Use <code>-h</code><br />
and you will see all the available options.</p>
<h2>Adding bean to the Camel <code>Registry</code></h2>
<p>In the <code>TimerRouteBuilder</code> example above, we have created a <code>Processor</code> on<br />
the fly. Now if you were to combine few different <code>Processor</code> together, it<br />
would be nicer to minimize the noise. Camel allow you to do this by registering<br />
processing beans in their registry space, and then you simply reference them in<br />
your route as <code>bean</code> component. Here is how I can convert above example into<br />
beans processing.</p>
<pre><code>package camelcoredemo;

import org.slf4j.*;
import org.apache.camel.*;
import org.apache.camel.builder.*;
import org.apache.camel.main.Main;

public class TimerBeansMain extends Main {
    static Logger LOG = LoggerFactory.getLogger(TimerBeansMain.class);
    public static void main(String[] args) throws Exception {
        TimerBeansMain main = new TimerBeansMain();
        main.enableHangupSupport();
        main.bind(&quot;processByBean1&quot;, new Bean1());
        main.bind(&quot;processAgainByBean2&quot;, new Bean2());
        main.addRouteBuilder(createRouteBuilder());
        main.run(args);
    }
    static RouteBuilder createRouteBuilder() {
        return new RouteBuilder() {
                public void configure() {
                    from(&quot;timer://timer1?period=1000&quot;)
                    .to(&quot;bean:processByBean1&quot;)
                    .to(&quot;bean:processAgainByBean2&quot;);
                }
            };
    }

    // Processor beans
    static class Bean1 implements Processor {
        public void process(Exchange msg) {
            LOG.info(&quot;First process {}&quot;, msg);
        }
    }
    static class Bean2 implements Processor {
        public void process(Exchange msg) {
            LOG.info(&quot;Second process {}&quot;, msg);
        }
    }
}
</code></pre>
<p>Now you see my <code>Route</code> is very slim and without noise clutter; and I have<br />
refactored my processing code into individual classes. This promotes better<br />
code management and testing as you write more complex <code>Route</code> to address<br />
business logic. It let you build LEGO like block of re-usable POJO beans.<br />
Besides just processing beans, Camel use this registry space for many other<br />
services as well. For example you may customize many other component endpoints<br />
with additional features and or configurations. Or thing such as thread<br />
pool strategy implementation replacement etc.</p>
<p>The <code>Route</code> in example above is constructed using what’s called Java DSL.<br />
The route is very readable, and yet you’ll get full IDE support to browse all the methods available to use for your route.</p>
<p>I hope this article has helped you jump start your Camel ride. Besides the<br />
<code>timer</code> component mentioned, the <code>camel-core</code> also comes with the following<br />
components out of it’s core jar.</p>
<ul>
<li></li>
</ul>
<p><a href="http://camel.apache.org/bean.html">bean component</a></p>
<ul>
<li></li>
</ul>
<p><a href="http://camel.apache.org/browse.html">browse component</a></p>
<ul>
<li></li>
</ul>
<p><a href="http://camel.apache.org/dataset.html">dataset component</a></p>
<ul>
<li></li>
</ul>
<p><a href="http://camel.apache.org/direct.html">direct component</a></p>
<ul>
<li></li>
</ul>
<p><a href="http://camel.apache.org/file.html">file component</a></p>
<ul>
<li></li>
</ul>
<p><a href="http://camel.apache.org/log.html">log component</a></p>
<ul>
<li></li>
</ul>
<p><a href="http://camel.apache.org/mock.html">mock component</a></p>
<ul>
<li></li>
</ul>
<p><a href="http://camel.apache.org/properties.html">properties component</a></p>
<ul>
<li></li>
</ul>
<p><a href="http://camel.apache.org/seda.html">seda component</a></p>
<ul>
<li></li>
</ul>
<p><a href="http://camel.apache.org/test.html">test component</a></p>
<ul>
<li></li>
</ul>
<p><a href="http://camel.apache.org/timer.html">timer component</a></p>
<ul>
<li></li>
</ul>
<p><a href="http://camel.apache.org/stub.html">stub component</a></p>
<ul>
<li></li>
</ul>
<p><a href="http://camel.apache.org/validation.html">validator component</a></p>
<ul>
<li></li>
</ul>
<p><a href="http://camel.apache.org/vm.html">vm component</a></p>
<ul>
<li></li>
</ul>
<p><a href="http://camel.apache.org/xslt.html">xslt component</a></p>
<p>Have fun!</p>
</p>
  			<a href="blog/2013/08/how-to-configure-slf4j-with-different-logger-implementations.html"><h1>How to configure SLF4J with different logger implementations</h1></a>
  			<p>18 August 2013, tags: 
			    <a href="../tags/slf4j.html">slf4j</a> 

			    <a href="../tags/logging.html">logging</a> 
  			</p>
  			<p><p>There are many good benefits in using <code>slf4j</code> library as your Java<br />
application logging API layer. Here I will show few examples on how<br />
to use and configure it with different loggers.</p>
<p>You can think of <code>slf4j</code> as an Java interface, and then you would<br />
need an implementation (ONLY ONE) at runtime to provide the actual<br />
logging details, such as writing to STDOUT or to a file etc. Each<br />
logging implementation (or called binding) would obviously have their<br />
own way of configuring the log output, but your application will remain<br />
agnostic and always use the same <code>org.slf4j.Logger</code> API. Lets see how<br />
this works in practice.</p>
<h2></h2>
<p>Using <code>slf4j</code> with Simple logger</p>
<p>Create a Maven based project and this in your <code>pom.xml</code>.</p>
<pre><code>    &lt;dependency&gt;
        &lt;groupId&gt;org.slf4j&lt;/groupId&gt;
        &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt;
        &lt;version&gt;1.7.5&lt;/version&gt;
    &lt;/dependency&gt;
</code></pre>
<p>Now you may use <code>Logger</code> in your Java code like this.</p>
<pre><code>package deng;
import org.slf4j.*;
public class Hello {
    static Logger LOGGER = LoggerFactory.getLogger(Hello.class);
    public static void main(String[] args) {
        for (int i = 0; i &lt; 10; i++)
            if (i % 2 == 0)
                LOGGER.info(&quot;Hello {}&quot;, i);
            else
                LOGGER.debug(&quot;I am on index {}&quot;, i);
    }
}
</code></pre>
<p>The above will get your program compiled, but when you run it, you will see these output.</p>
<pre><code>bash&gt; java deng.Hello
SLF4J: Failed to load class &quot;org.slf4j.impl.StaticLoggerBinder&quot;.
SLF4J: Defaulting to no-operation (NOP) logger implementation
SLF4J: See http://www.slf4j.org/codes.html#StaticLoggerBinder for further details.
</code></pre>
<p>What its saying is that at runtime, you are missing the logging &quot;implementation&quot; (or the<br />
logger binding), so <code>slf4j</code> simply use a &quot;NOP&quot; implmentation, which does nothing. In order<br />
to see the output properly, you may try use an simple implementation that does not require<br />
any configuration at all! Just go back to your <code>pom.xml</code> and add the following:</p>
<pre><code>    &lt;dependency&gt;
        &lt;groupId&gt;org.slf4j&lt;/groupId&gt;
        &lt;artifactId&gt;slf4j-simple&lt;/artifactId&gt;
        &lt;version&gt;1.7.5&lt;/version&gt;
    &lt;/dependency&gt;
</code></pre>
<p>Now you see logging output on STDOUT with INFO level. This simple logger will default<br />
show any INFO level message or higher. In order to see DEBUG messages, you would<br />
need to pass in this System Property <code>-Dorg.slf4j.simpleLogger.defaultLogLevel=DEBUG</code><br />
at your Java startup.</p>
<h2></h2>
<p>Using <code>slf4j</code> with Log4j logger</p>
<p>Now we can experiment and swap different logger implementations, but your application code<br />
can remain the same. All we need is to replace <code>slf4j-simple</code> with another popular logger<br />
implementation, such as the Log4j.</p>
<pre><code>    &lt;dependency&gt;
        &lt;groupId&gt;org.slf4j&lt;/groupId&gt;
        &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;
        &lt;version&gt;1.7.5&lt;/version&gt;
    &lt;/dependency&gt;
</code></pre>
<p>Again, we must configure logging per implementation that we picked.<br />
In this case, we need an <code>src/main/resources/log4j.properties</code> file.</p>
<pre><code>    log4j.rootLogger=DEBUG, STDOUT
    log4j.logger.deng=INFO
    log4j.appender.STDOUT=org.apache.log4j.ConsoleAppender
    log4j.appender.STDOUT.layout=org.apache.log4j.PatternLayout
    log4j.appender.STDOUT.layout.ConversionPattern=%5p [%t] (%F:%L) - %m%n
</code></pre>
<p>Re-run your program, and you should see similar output.</p>
<h2></h2>
<p>Using <code>slf4j</code> with JDK logger</p>
<p>The JDK actually comes with a logger package, and you can replace <code>pom.xml</code><br />
with this logger implementation.</p>
<pre><code>    &lt;dependency&gt;
        &lt;groupId&gt;org.slf4j&lt;/groupId&gt;
        &lt;artifactId&gt;slf4j-jdk14&lt;/artifactId&gt;
        &lt;version&gt;1.7.5&lt;/version&gt;
    &lt;/dependency&gt;
</code></pre>
<p>Now the configuration for JDK logging is a bit difficult to work with. Not only need a<br />
config file, such as <code>src/main/resources/logging.properties</code>, but you would also need<br />
to add a System properties <code>-Djava.util.logging.config.file=logging.properties</code><br />
in order to have it pick it up. Here is an example to get you started:</p>
<pre><code>.level=INFO

handlers=java.util.logging.ConsoleHandler
java.util.logging.ConsoleHandler.level=FINEST
deng.level=FINEST
</code></pre>
<h2></h2>
<p>Using <code>slf4j</code> with Logback logger</p>
<p>The logback logger implementation is a super dupa quality implementation. If you intend<br />
to write serious code that go into production, you may want to evaluate this option. Again<br />
modify your <code>pom.xml</code> to replace with this:</p>
<pre><code>    &lt;dependency&gt;
        &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;
        &lt;artifactId&gt;logback-classic&lt;/artifactId&gt;
        &lt;version&gt;1.0.13&lt;/version&gt;
    &lt;/dependency&gt;
</code></pre>
<p>Here is a sample of configuration <code>src/main/resources/logback.xml</code> to get things started.</p>
<pre><code>&lt;configuration&gt;
  &lt;appender name=&quot;STDOUT&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt;
    &lt;encoder&gt;
      &lt;pattern&gt;%d{HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n&lt;/pattern&gt;
    &lt;/encoder&gt;
  &lt;/appender&gt;

  &lt;logger name=&quot;deng&quot; level=&quot;DEBUG&quot;/&gt;

  &lt;root level=&quot;INFO&quot;&gt;
    &lt;appender-ref ref=&quot;STDOUT&quot; /&gt;
  &lt;/root&gt;
&lt;/configuration&gt;
</code></pre>
<h2></h2>
<p>Writing your own library with <code>slf4j</code> logger</p>
<p>If you are providing an Java library for large end users consumption, its good idea to<br />
set your project to depend on <code>slf4j-api</code> only, and then let your user choose any<br />
logger implementation at their development or runtime environment. As end users, they<br />
may quickly select one of option above and take advatage of their own favorite logging<br />
implementation features.</p>
<h2></h2>
<p>References</p>
<ul>
<li>
<p><a href="http://slf4j.org/">http://slf4j.org/</a></p>
</li>
<li>
<p><a href="http://logging.apache.org/log4j/1.2/">http://logging.apache.org/log4j/1.2/</a></p>
</li>
<li>
<p><a href="http://docs.oracle.com/javase/7/docs/technotes/guides/logging/">http://docs.oracle.com/javase/7/docs/technotes/guides/logging/</a></p>
</li>
<li>
<p><a href="http://logback.qos.ch/">http://logback.qos.ch/</a></p>
</li>
</ul>
</p>

	<hr />

	<ul class="pager">
		<li class="previous"><a href="https://zemian.github.io/18">Previous</a></li>
		<li>Page: 19/28</li>
		<li class="next"><a href="https://zemian.github.io/20">Next</a></li>
	</ul>

		</div>
		<div id="push"></div>
    </div>
    
    <div id="footer">
      <div class="container">
        <p class="muted credit">&copy; 2011 - Present Zemian Deng All Rights Reserved | Mixed with <a href="http://getbootstrap.com/">Bootstrap v3.1.1</a> | Baked with <a href="http://jbake.org">JBake v2.6.5</a></p>
      </div>
    </div>
    
    <!-- Le javascript
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="../js/jquery-1.11.1.min.js"></script>
    <script src="../js/bootstrap.min.js"></script>
    <script src="../js/prettify.js"></script>
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-135626598-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-135626598-1');
    </script>

  </body>
</html>