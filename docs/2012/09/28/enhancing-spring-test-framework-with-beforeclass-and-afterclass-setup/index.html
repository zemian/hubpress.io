<!DOCTYPE html>
<html lang="en-us">

  <head>
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <title>
    
      Enhancing Spring Test Framework with beforeClass and afterClass setup &middot; Zemian's Blog
    
  </title>

  
  <link rel="canonical" href="http://localhost:4000/2012/09/28/enhancing-spring-test-framework-with-beforeclass-and-afterclass-setup/">
  

  <link rel="stylesheet" href="http://localhost:4000/public/css/poole.css">
  <link rel="stylesheet" href="http://localhost:4000/public/css/syntax.css">
  <link rel="stylesheet" href="http://localhost:4000/public/css/lanyon.css">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=PT+Serif:400,400italic,700%7CPT+Sans:400">

  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="http://localhost:4000/public/apple-touch-icon-precomposed.png">
  <link rel="shortcut icon" href="http://localhost:4000/public/favicon.ico">

  <link rel="alternate" type="application/rss+xml" title="RSS" href="http://localhost:4000/atom.xml">

  
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
    ga('create', 'UA-135626598-1', 'auto');
    ga('send', 'pageview');
  </script>
  
</head>


  <body>

    <!-- Target for toggling the sidebar `.sidebar-checkbox` is for regular
     styles, `#sidebar-checkbox` for behavior. -->
<input type="checkbox" class="sidebar-checkbox" id="sidebar-checkbox">

<!-- Toggleable sidebar -->
<div class="sidebar" id="sidebar">
  <div class="sidebar-item">
    <p>A weblog on software development.</p>
  </div>

  <nav class="sidebar-nav">
    <a class="sidebar-nav-item" href="http://localhost:4000/">Home</a>

    

    
    
      
        
      
    
      
        
      
    
      
        
          <a class="sidebar-nav-item" href="http://localhost:4000/about/">About</a>
        
      
    
      
    
      
    
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    

  </nav>

  <div class="sidebar-item">
    <p>
      &copy; 2020. All rights reserved.
    </p>
  </div>
</div>


    <!-- Wrap is the content to shift when toggling the sidebar. We wrap the
         content to avoid any CSS collisions with our real content. -->
    <div class="wrap">
      <div class="masthead">
        <div class="container">
          <h3 class="masthead-title">
            <a href="/" title="Home">Zemian's Blog</a>
            <small>Life in programming world!</small>
          </h3>
        </div>
      </div>

      <div class="container content">
        <div class="post">
  <h1 class="post-title">Enhancing Spring Test Framework with beforeClass and afterClass setup</h1>
  <span class="post-date">28 Sep 2012</span>
  <h1 id="how-to-allow-instance-methods-to-run-as-junit-beforeclass-behavior">How to allow instance methods to run as JUnit BeforeClass behavior</h1>

<p>JUnit allows you to setup methods on the class level once before and after all tests methods invocation. However, by design on purpose that they restrict this to only <em>static</em> methods using <code class="language-plaintext highlighter-rouge">@BeforeClass</code> and <code class="language-plaintext highlighter-rouge">@AfterClass</code> annotations. For example this simple demo shows the typical Junit setup:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    package deng.junitdemo;
    
    import org.junit.AfterClass;
    import org.junit.BeforeClass;
    import org.junit.Test;
    
    public class DemoTest {
    
        @Test
        public void testOne() {
            System.out.println("Normal test method #1.");
        }
    
        @Test
        public void testTwo() {
            System.out.println("Normal test method #2.");
        }
    
        @BeforeClass
        public static void beforeClassSetup() {
            System.out.println("A static method setup before class.");
        }
    
        @AfterClass
        public static void afterClassSetup() {
            System.out.println("A static method setup after class.");
        }
    }
</code></pre></div></div>

<p>And above should result the following output:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    A static method setup before class.
    Normal test method #1.
    Normal test method #2.
    A static method setup after class.
</code></pre></div></div>

<p>This usage is fine for most of the time, but there are times you want to use non-static methods to setup the test. I will show you a more detailed use case later, but for now, letâ€™s see how we can solve this naughty problem with JUnit first. We can solve this by making the test
implements a Listener that provide the before and after callbacks, and we will need to digg into JUnit to detect this Listener to invoke our methods. This is a solution I came up with:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    package deng.junitdemo;
    
    import org.junit.Test;
    import org.junit.runner.RunWith;
    
    @RunWith(InstanceTestClassRunner.class)
    public class Demo2Test implements InstanceTestClassListener {
    
        @Test
        public void testOne() {
            System.out.println("Normal test method #1");
        }
    
        @Test
        public void testTwo() {
            System.out.println("Normal test method #2");
        }
    
        @Override
        public void beforeClassSetup() {
            System.out.println("An instance method setup before class.");
        }
    
        @Override
        public void afterClassSetup() {
            System.out.println("An instance method setup after class.");
        }
    }
</code></pre></div></div>

<p>As stated above, our Listener is a simple contract:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    package deng.junitdemo;
    
    public interface InstanceTestClassListener {
        void beforeClassSetup();
        void afterClassSetup();
    }
</code></pre></div></div>

<p>Our next task is to provide the JUnit runner implementation that will trigger the setup methods.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    package deng.junitdemo;
    
    import org.junit.runner.notification.RunNotifier;
    import org.junit.runners.BlockJUnit4ClassRunner;
    import org.junit.runners.model.InitializationError;
    
    public class InstanceTestClassRunner extends BlockJUnit4ClassRunner {
    
        private InstanceTestClassListener instanceSetupListener;
    
        public InstanceTestClassRunner(Class&lt;?&gt; klass) throws InitializationError {
            super(klass);
        }
    
        @Override
        protected Object createTest() throws Exception {
            Object test = super.createTest();
            // Note that JUnit4 will call this createTest() multiple times for each
            // test method, so we need to ensure to call "beforeClassSetup" only once.
            if (test instanceof InstanceTestClassListener &amp;&amp; instanceSetupListener == null) {
                instanceSetupListener = (InstanceTestClassListener) test;
                instanceSetupListener.beforeClassSetup();
            }
            return test;
        }
    
        @Override
        public void run(RunNotifier notifier) {
            super.run(notifier);
            if (instanceSetupListener != null)
                instanceSetupListener.afterClassSetup();
        }
    }
</code></pre></div></div>

<p>Now we are in business. If we run above test, it should give us similar result, but this time we are using instance methods instead!</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    An instance method setup before class.
    Normal test method #1
    Normal test method #2
    An instance method setup after class.
</code></pre></div></div>

<h1 id="a-concrete-use-case-working-with-spring-test-framework">A concrete use case: Working with Spring Test Framework</h1>

<p>Now let me show you a real use case with above. If you use Spring Test Framework, you would normally setup a test like this so that you may have test fixture injected as member instance.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    package deng.junitdemo.spring;
    
    import static org.hamcrest.Matchers.is;
    import static org.junit.Assert.assertThat;
    
    import java.util.List;
    
    import javax.annotation.Resource;
    
    import org.junit.Test;
    import org.junit.runner.RunWith;
    import org.springframework.test.context.ContextConfiguration;
    import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;
    
    @RunWith(SpringJUnit4ClassRunner.class)
    @ContextConfiguration
    public class SpringDemoTest {
    
        @Resource(name="myList")
        private List&lt;String&gt; myList;
    
        @Test
        public void testMyListInjection() {
            assertThat(myList.size(), is(2));
        }
    }
</code></pre></div></div>

<p>You would also need a spring xml under that same package for above to run:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    &lt;?xml version="1.0" encoding="UTF-8"?&gt;
    &lt;beans xmlns="http://www.springframework.org/schema/beans"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt;
         &lt;bean id="myList" class="java.util.ArrayList"&gt;
            &lt;constructor-arg&gt;
                &lt;list&gt;
                    &lt;value&gt;one&lt;/value&gt;
                    &lt;value&gt;two&lt;/value&gt;
                &lt;/list&gt;
            &lt;/constructor-arg&gt;
         &lt;/bean&gt;
    &lt;/beans&gt;
</code></pre></div></div>

<p>Pay very close attention to member instance <code class="language-plaintext highlighter-rouge">List&lt;String&gt; myList</code>. When running JUnit test, that field will be injected by Spring, and it can be used in any test method. However, if you ever want a one time setup of some code and get a reference to a Spring injected field, then you are in bad luck. This is because the JUnit <code class="language-plaintext highlighter-rouge">@BeforeClass</code> will force your method to be static; and if you make your field static, Spring injection wonâ€™t work in your test!</p>

<p>Now if you are a frequent Spring user, you should know that Spring Test Framework already provided a way for you to handle this type of use case. Here is a way for you to do class level setup with Springâ€™s style:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    package deng.junitdemo.spring;
    
    import static org.hamcrest.Matchers.is;
    import static org.junit.Assert.assertThat;
    
    import java.util.List;
    
    import javax.annotation.Resource;
    
    import org.junit.Test;
    import org.junit.runner.RunWith;
    import org.springframework.test.context.ContextConfiguration;
    import org.springframework.test.context.TestContext;
    import org.springframework.test.context.TestExecutionListeners;
    import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;
    import org.springframework.test.context.support.AbstractTestExecutionListener;
    import org.springframework.test.context.support.DependencyInjectionTestExecutionListener;
    
    @RunWith(SpringJUnit4ClassRunner.class)
    @TestExecutionListeners(listeners = {
            DependencyInjectionTestExecutionListener.class, 
            SpringDemo2Test.class})
    @ContextConfiguration
    public class SpringDemo2Test extends AbstractTestExecutionListener {
    
        @Resource(name="myList")
        private List&lt;String&gt; myList;
    
        @Test
        public void testMyListInjection() {
            assertThat(myList.size(), is(2));
        }
    
        @Override
        public void afterTestClass(TestContext testContext) {
            List&lt;?&gt; list = testContext.getApplicationContext().getBean("myList", List.class);
            assertThat((String)list.get(0), is("one"));
        }
    
        @Override
        public void beforeTestClass(TestContext testContext) {
            List&lt;?&gt; list = testContext.getApplicationContext().getBean("myList", List.class);
            assertThat((String)list.get(1), is("two"));
        }
    }
</code></pre></div></div>

<p>As you can see, Spring offers the <code class="language-plaintext highlighter-rouge">@TestExecutionListeners</code> annotation to allow you to write any Listener, and in it you will have a reference to the <code class="language-plaintext highlighter-rouge">TestContext</code> which has the <code class="language-plaintext highlighter-rouge">ApplicationContext</code> for you to get to the injected field reference. This works, but I find it not very elegant. It forces you to look up the bean, while your injected field is already available as field. But you canâ€™t use it unless you go through the <code class="language-plaintext highlighter-rouge">TestContext</code> parameter.</p>

<p>Now if you mix the solution we provided in the beginning, we will see a more prettier test setup. Letâ€™s see it:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    package deng.junitdemo.spring;
    
    import static org.hamcrest.Matchers.is;
    import static org.junit.Assert.assertThat;
    
    import java.util.List;
    
    import javax.annotation.Resource;
    
    import org.junit.Test;
    import org.junit.runner.RunWith;
    import org.springframework.test.context.ContextConfiguration;
    
    import deng.junitdemo.InstanceTestClassListener;
    
    @RunWith(SpringInstanceTestClassRunner.class)
    @ContextConfiguration
    public class SpringDemo3Test implements InstanceTestClassListener {
    
        @Resource(name="myList")
        private List&lt;String&gt; myList;
    
        @Test
        public void testMyListInjection() {
            assertThat(myList.size(), is(2));
        }
    
        @Override
        public void beforeClassSetup() {
            assertThat((String)myList.get(0), is("one"));
        }
    
        @Override
        public void afterClassSetup() {
            assertThat((String)myList.get(1), is("two"));
        }
    }
</code></pre></div></div>

<p>Now JUnit only allow you to use single <code class="language-plaintext highlighter-rouge">Runner</code>, so we must extends the Springâ€™s version to insert what we did before.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    package deng.junitdemo.spring;
    
    import org.junit.runner.notification.RunNotifier;
    import org.junit.runners.model.InitializationError;
    import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;
    
    import deng.junitdemo.InstanceTestClassListener;
    
    public class SpringInstanceTestClassRunner extends SpringJUnit4ClassRunner {
    
        private InstanceTestClassListener instanceSetupListener;
    
        public SpringInstanceTestClassRunner(Class&lt;?&gt; clazz) throws InitializationError {
            super(clazz);
        }
    
        @Override
        protected Object createTest() throws Exception {
            Object test = super.createTest();
            // Note that JUnit4 will call this createTest() multiple times for each
            // test method, so we need to ensure to call "beforeClassSetup" only once.
            if (test instanceof InstanceTestClassListener &amp;&amp; instanceSetupListener == null) {
                instanceSetupListener = (InstanceTestClassListener) test;
                instanceSetupListener.beforeClassSetup();
            }
            return test;
        }
    
        @Override
        public void run(RunNotifier notifier) {
            super.run(notifier);
            if (instanceSetupListener != null)
                instanceSetupListener.afterClassSetup();
        }
    }
</code></pre></div></div>

<p>That should do the trick. Running the test will give use this output:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    12:58:48 main INFO  org.springframework.test.context.support.AbstractContextLoader:139 | Detected default resource location "classpath:/deng/junitdemo/spring/SpringDemo3Test-context.xml" for test class [deng.junitdemo.spring.SpringDemo3Test].
    12:58:48 main INFO  org.springframework.test.context.support.DelegatingSmartContextLoader:148 | GenericXmlContextLoader detected default locations for context configuration [ContextConfigurationAttributes@74b23210 declaringClass = 'deng.junitdemo.spring.SpringDemo3Test', locations = '{classpath:/deng/junitdemo/spring/SpringDemo3Test-context.xml}', classes = '{}', inheritLocations = true, contextLoaderClass = 'org.springframework.test.context.ContextLoader'].
    12:58:48 main INFO  org.springframework.test.context.support.AnnotationConfigContextLoader:150 | Could not detect default configuration classes for test class [deng.junitdemo.spring.SpringDemo3Test]: SpringDemo3Test does not declare any static, non-private, non-final, inner classes annotated with @Configuration.
    12:58:48 main INFO  org.springframework.test.context.TestContextManager:185 | @TestExecutionListeners is not present for class [class deng.junitdemo.spring.SpringDemo3Test]: using defaults.
    12:58:48 main INFO  org.springframework.beans.factory.xml.XmlBeanDefinitionReader:315 | Loading XML bean definitions from class path resource [deng/junitdemo/spring/SpringDemo3Test-context.xml]
    12:58:48 main INFO  org.springframework.context.support.GenericApplicationContext:500 | Refreshing org.springframework.context.support.GenericApplicationContext@44c9d92c: startup date [Sat Sep 29 12:58:48 EDT 2012]; root of context hierarchy
    12:58:49 main INFO  org.springframework.beans.factory.support.DefaultListableBeanFactory:581 | Pre-instantiating singletons in org.springframework.beans.factory.support.DefaultListableBeanFactory@73c6641: defining beans [myList,org.springframework.context.annotation.internalConfigurationAnnotationProcessor,org.springframework.context.annotation.internalAutowiredAnnotationProcessor,org.springframework.context.annotation.internalRequiredAnnotationProcessor,org.springframework.context.annotation.internalCommonAnnotationProcessor,org.springframework.context.annotation.ConfigurationClassPostProcessor$ImportAwareBeanPostProcessor#0]; root of factory hierarchy
    12:58:49 Thread-1 INFO  org.springframework.context.support.GenericApplicationContext:1025 | Closing org.springframework.context.support.GenericApplicationContext@44c9d92c: startup date [Sat Sep 29 12:58:48 EDT 2012]; root of context hierarchy
    12:58:49 Thread-1 INFO  org.springframework.beans.factory.support.DefaultListableBeanFactory:433 | Destroying singletons in org.springframework.beans.factory.support.DefaultListableBeanFactory@73c6641: defining beans [myList,org.springframework.context.annotation.internalConfigurationAnnotationProcessor,org.springframework.context.annotation.internalAutowiredAnnotationProcessor,org.springframework.context.annotation.internalRequiredAnnotationProcessor,org.springframework.context.annotation.internalCommonAnnotationProcessor,org.springframework.context.annotation.ConfigurationClassPostProcessor$ImportAwareBeanPostProcessor#0]; root of factory hierarchy
</code></pre></div></div>

<p>Obviously the output shows nothing interesting here, but the test should run with all assertion passed. The point is that now we have a more elegant way to invoking a before and after test setup that are at class level, and they can be instance methods to allow Spring injection.</p>

<h1 id="download-the-demo-code">Download the demo code</h1>

<p>You may get above demo code in a working Maven project from <a href="https://bitbucket.org/saltnlight5/sandbox/src/8d545b15fbbd/junit-examples">my sandbox</a>.</p>

</div>


<div class="related">
  <h2>Related posts</h2>
  <ul class="related-posts">
    
      <li>
        <h3>
          <a href="/2020/09/20/world-of-php/">
            The World of PHP Development
            <small>20 Sep 2020</small>
          </a>
        </h3>
      </li>
    
      <li>
        <h3>
          <a href="/2020/09/19/multiple-jquery/">
            How to Load Multiple jQuery
            <small>19 Sep 2020</small>
          </a>
        </h3>
      </li>
    
      <li>
        <h3>
          <a href="/2020/08/15/switched-to-vuepress/">
            Switched Blogging to VuePress
            <small>15 Aug 2020</small>
          </a>
        </h3>
      </li>
    
  </ul>
</div>


      </div>
    </div>

    <label for="sidebar-checkbox" class="sidebar-toggle"></label>

    <script src='/public/js/script.js'></script>
  </body>
</html>
