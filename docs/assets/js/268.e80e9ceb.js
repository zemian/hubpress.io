(window.webpackJsonp=window.webpackJsonp||[]).push([[268],{650:function(e,n,t){"use strict";t.r(n);var r=t(10),s=Object(r.a)({},(function(){var e=this.$createElement,n=this._self._c||e;return n("ContentSlotsDistributor",{attrs:{"slot-key":this.$parent.slotKey}},[n("p",[this._v("With Java8, we can create simple and thin Jdbc service that’s productive\nand easy to use. This service implementation is inspired by Spring’s\nJdbcTemplate, but much lighter and has zero dependency.")]),this._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[this._v('package zemian.jdbc;\n\nimport javax.sql.DataSource;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.net.URL;\nimport java.sql.*;\nimport java.util.*;\nimport java.util.stream.Collectors;\n\n/**\n * This class provide an easier interface to run SQLs and retrieve data than direct Java JDBC API.\n *\n * You can instantiate this class in two ways:\n *\n * - Method1: Using a DataSource. Each operation will get a Connection object from the #dataSource.\n * - Method2: Using a direct Connection object. Use this to reuse a single connection to perform all\n *            JDBC operations.\n *\n * Both methods above will not directly close the Connection object per Jdbc instance. It\'s user\n * responsibility to close it after use. For pooled DataSource, it should be automatic, else you\n * might want to use the Jdbc.withJdbc() convenient method. This method will let you quickly start a single\n * new DB connection and Jdbc instance, and it will auto close connection when method is exited.\n *\n * This class provide these easy methods to work with DB data:\n * - #execute() perform update SQLs that returns number of records updated.\n * - #query() perform select SQLs that returns a list of records.\n * - #get() perform select SQLs that return a single object element.\n * - #insert() perform table insert using a Map as record.\n * - #update() perform table update using a Map as record.\n *\n * The #query() and #get() methods allow you to provide custom RSMapper to convert ResultSet instance\n * into any user object.\n *\n * @author Zemian Deng 2018-07-28\n */\npublic class Jdbc {\n    // == Static utility methods and supporting inner classes\n    public static void withJdbc(String propsResourceName, JdbcAction task) {\n        Properties props = new Properties();\n        URL propsUrl = Thread.currentThread().getContextClassLoader().getResource(propsResourceName);\n        try (InputStream ins = propsUrl.openStream()) {\n            props.load(ins);\n        } catch (IOException e) {\n            throw new RuntimeException("Unable to open properties from resource: " + propsResourceName, e);\n        }\n        withJdbc(props, task);\n    }\n\n    public static void withJdbc(String url, String user, String password, JdbcAction task) {\n        Properties props = new Properties();\n        props.setProperty("url", url);\n        props.setProperty("user", user);\n        props.setProperty("password", password);\n        withJdbc(props, task);\n    }\n\n    public static void withJdbc(Properties jdbcProps, JdbcAction task) {\n        try (Connection conn = DriverManager.getConnection(jdbcProps.getProperty("url"), jdbcProps)) {\n            Jdbc jdbc = new Jdbc(conn);\n            task.runJdbc(jdbc);\n        } catch (Exception e) {\n            if (e instanceof RuntimeException)\n                throw (RuntimeException) e;\n            throw new RuntimeException("Failed to process Jdbc", e);\n        }\n    }\n\n    public static List<String> getFieldNames(ResultSet rs) throws SQLException {\n        List<String> names = new ArrayList<>();\n        ResultSetMetaData md = rs.getMetaData();\n        for (int i = 1, max = md.getColumnCount(); i <= max; i++) {\n            names.add(md.getColumnName(i));\n        }\n        return names;\n    }\n\n    public static void setParams(PreparedStatement st, Object[] params) throws SQLException {\n        for (int i = 0; i < params.length; i++) {\n            st.setObject(i + 1, params[i]);\n        }\n    }\n\n    interface JdbcAction {\n        void runJdbc(Jdbc jdbc) throws Exception;\n    }\n\n    interface ConnAction<T> {\n        T runConn(Connection conn) throws Exception;\n    }\n\n    interface ConnActionNoRet {\n        void runConn(Connection conn) throws Exception;\n    }\n\n    interface RSMapper<T> {\n        T map(ResultSet rs, int idx) throws Exception;\n    }\n\n    public static class Record extends HashMap<String, Object> {\n        public Record() {}\n        public Record(ResultSet rs) throws SQLException {\n            this(rs, Jdbc.getFieldNames(rs));\n        }\n        public Record(ResultSet rs, List<String> names) throws SQLException {\n            for (String name : names) {\n                Object val = rs.getObject(name);\n                put(name, val);\n            }\n        }\n        public Record(Object ... entries) {\n            for (int i = 0; i < entries.length; i+= 2) {\n                Object key = entries[i];\n                Object val = entries[i + 1];\n                put(key.toString(), val);\n            }\n        }\n        public <T> T getValue(String key) {\n            return (T) get(key);\n        }\n        public List<String> getFieldNames() {\n            return new ArrayList<>(keySet());\n        }\n        @Override\n        public String toString() {\n            return "Record" + super.toString();\n        }\n    }\n\n    // == Jdbc Service implementation\n    private DataSource dataSource;\n    private Connection conn;\n\n    public Jdbc(Connection conn) {\n        this.conn = conn;\n    }\n\n    public Jdbc(DataSource dataSource) {\n        this.dataSource = dataSource;\n    }\n\n    public Connection getConn() throws SQLException {\n        if (conn != null) {\n            return conn;\n        } else {\n            return dataSource.getConnection();\n        }\n    }\n\n    public <T> T withConn(ConnAction<T> action) {\n        try {\n            return action.runConn(getConn());\n        } catch (Exception e) {\n            if (e instanceof RuntimeException)\n                throw (RuntimeException) e;\n            throw new RuntimeException("Failed to process DB conn", e);\n        }\n    }\n\n    public void withConnNoRet(ConnActionNoRet action) {\n        withConn(conn -> {\n            action.runConn(conn);\n            return null;\n        });\n    }\n\n    public <T> T get(String sql, Object ... params) {\n        return get((rs, idx) -> (T) rs.getObject(1), sql, params);\n    }\n\n    public <T> T get(RSMapper<T> mapper, String sql, Object ... params) {\n        return withConn(conn -> {\n            try (PreparedStatement st = conn.prepareStatement(sql)) {\n                setParams(st, params);\n                st.executeQuery();\n                try (ResultSet rs = st.getResultSet()) {\n                    if (rs.next()) {\n                        return mapper.map(rs, 0);\n                    }\n                }\n            }\n            throw new RuntimeException("There is no unique record from query.");\n        });\n    }\n\n    public Record getRecord(String sql, Object ... params) {\n        return get((rs, idx) -> new Record(rs), sql, params);\n    }\n\n    public List<Record> query(String sql, Object ... params) {\n        final List<String> names = new ArrayList<>();\n        return query((rs, idx) -> {\n            if (idx == 0) {\n                names.addAll(getFieldNames(rs));\n            }\n            return new Record(rs, names);\n        }, sql, params);\n    }\n\n    public <T> List<T> query(RSMapper<T> mapper, String sql, Object ... params) {\n        return withConn(conn -> {\n            List<T> list = new ArrayList<>();\n            try (PreparedStatement st = conn.prepareStatement(sql)) {\n                setParams(st, params);\n                st.executeQuery();\n                try (ResultSet rs = st.getResultSet()) {\n                    int idx = 0;\n                    while (rs.next()) {\n                        T t = mapper.map(rs, idx++);\n                        list.add(t);\n                    }\n                }\n            }\n            return list;\n        });\n    }\n\n    public int execute(String sql, Object ... params) {\n        return withConn(conn -> {\n            try (PreparedStatement st = conn.prepareStatement(sql)) {\n                setParams(st, params);\n                return st.executeUpdate();\n            }\n        });\n    }\n\n    public int insert(String table, Record record) {\n        return insert(table, record, record.getFieldNames());\n    }\n\n    public int insert(String table, Record record, List<String> insertFields) {\n        String fields = insertFields.stream().collect(Collectors.joining(", "));\n        String qMarks = insertFields.stream().map(e -> "?").collect(Collectors.joining(", "));\n        String sql = "INSERT INTO " + table + "(" + fields + ") VALUES (" + qMarks + ")";\n        List<Object> params = insertFields.stream().map(e -> record.get(e)).collect(Collectors.toList());\n        return withConn(conn -> {\n            try (PreparedStatement st = conn.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS)) {\n                setParams(st, params.toArray());\n                int uc = st.executeUpdate();\n                // Check for auto generated keys, if present add into the record.\n                // NOTE it will not override existing fields in record!\n                try (ResultSet rs = st.getGeneratedKeys()) {\n                    if (rs.next()) {\n                        List<String> names = getFieldNames(rs);\n                        for (String name : names) {\n                            if (!record.containsKey(name))\n                                record.put(name, rs.getObject(name));\n                        }\n                    }\n                }\n                return uc;\n            }\n        });\n    }\n\n    public int update(String table, Record record, String ... keyFields) {\n        List<String> updateFields = record.getFieldNames();\n        for (String key : keyFields)\n            updateFields.remove(key);\n        return update(table, record, updateFields, Arrays.asList(keyFields));\n    }\n\n    public int update(String table, Record record, List<String> updateFields, List<String> keyFields) {\n        String updateFieldsNames = updateFields.stream().map(e -> e + " = ?").collect(Collectors.joining(", "));\n        String keyFieldsNames = keyFields.stream().map(e -> e + " = ?").collect(Collectors.joining(", "));\n        String sql = "UPDATE " + table + " SET " + updateFieldsNames + " WHERE " + keyFieldsNames;\n        List<Object> params = updateFields.stream().map(e -> record.get(e)).collect(Collectors.toList());\n        for (String key : keyFields)\n            params.add(record.get(key));\n        return execute(sql, params.toArray());\n    }\n\n    // Test Jdbc with Postgres DB\n    public static void main(String[] args) {\n        String url = System.getProperty("url", "jdbc:postgresql://localhost:5432/postgres");\n        String user = System.getProperty("user", "postgres");\n        String password = System.getProperty("password", "");\n\n        Jdbc.withJdbc(url, user, password, jdbc -> {\n            jdbc.withConnNoRet(conn -> System.out.println(conn));\n        });\n\n        Jdbc.withJdbc(url, user, password, jdbc -> {\n            // Execute\n            jdbc.execute("create temp table test(id varchar(10) primary key, seq serial, amount numeric(19,4))");\n            int uc = jdbc.execute("insert into test(id, amount) values(?, ?)", "T01", 0.01);\n            System.out.println("test record inserted: uc=" + uc);\n\n            Record record = jdbc.getRecord("select * from test where id = ?", "T01");\n            System.out.println(record);\n\n            // Get\n            Integer seq = jdbc.get("select seq from test where id = ?", "T01");\n            System.out.println("seq = " + seq);\n\n            java.math.BigDecimal amount = jdbc.get("select amount from test where id = ?", "T01");\n            System.out.println("amount = " + amount);\n\n            // Update\n            record.put("amount", amount.doubleValue() + 0.20);\n            System.out.println("amount to be updated: " + record.getValue("amount"));\n            uc = jdbc.update("test", record, "id");\n            System.out.println("amount udpated. uc=" + uc);\n\n            amount = jdbc.get("select amount from test where id = ?", "T01");\n            System.out.println("after update from db: amount = " + amount);\n\n            // Insert\n            record = new Record("id", "T02", "amount", 0.30);\n            jdbc.insert("test", record);\n            int newSeq = (Integer) record.get("seq");\n            System.out.println("generated column seq=" + newSeq);\n            Record record2 = jdbc.getRecord("select * from test where id = ?", "T02");\n            System.out.println(record2);\n\n            // Query\n            List<Record> records = jdbc.query("select * from test order by id");\n            System.out.println(records);\n        });\n    }\n}\n')])])])])}),[],!1,null,null,null);n.default=s.exports}}]);