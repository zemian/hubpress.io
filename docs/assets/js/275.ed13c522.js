(window.webpackJsonp=window.webpackJsonp||[]).push([[275],{657:function(t,e,n){"use strict";n.r(e);var a=n(10),s=Object(a.a)({},(function(){var t=this.$createElement,e=this._self._c||t;return e("ContentSlotsDistributor",{attrs:{"slot-key":this.$parent.slotKey}},[e("p",[this._v("A quick sql table setup to test most common data types.")]),this._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[this._v("-- Notes for SQLite3 Database (3.24)\n-- https://www.sqlite.org/docs.html\n\n-- Data Types\n-- https://www.sqlite.org/datatype3.html\n\n-- Functions\n-- https://www.sqlite.org/lang_corefunc.html\n\n/*\nSQLite does not have strong data type, but dynamic type that define by value rather than by schema/container.\n\nSQLite only has 5 storage class that it can be used to store data (desc their doc):\n\nNULL. The value is a NULL value.\nINTEGER. The value is a signed integer, stored in 1, 2, 3, 4, 6, or 8 bytes depending on the magnitude of the value.\nREAL. The value is a floating point value, stored as an 8-byte IEEE floating point number.\nTEXT. The value is a text string, stored using the database encoding (UTF-8, UTF-16BE or UTF-16LE).\nBLOB. The value is a blob of data, stored exactly as it was input.\n\nSQLite can conform to standard SQL types by mapping what's called \"affinity\" type.\n\nCHAR          Map to TEXT\nVARCHAR       Map to TEXT\nTEXT          Map to TEXT\n\nINT           Map to INTEGER\n\nREAL             Map to REAL\nDOUBLE PRECISION Map to REAL\n\nNUMERIC       Map to INTEGER, REAL, TEXT or BLOB\n\nDATE          Map to INTEGER, REAL, TEXT or BLOB\nDATETIME      Map to INTEGER, REAL, TEXT or BLOB\n\nNOTE: Despite there is a \"NUMERIC\" affinity type, it's not a fixed-point type! SQLite\ndoes not have native NUMERIC. It will dynamically choose a best fit storage class\ninstead (REAL if it can keep 15 digits accuracy). If you need true fixed point data type,\nyou may try to use TEXT data stored instead. Same as with DATETIME types. For example you\ncan store DATETIME as TEXT, and then SQLite provides many built-in functions that help you\nmanipulate dates instead. Note also that precision and scale such as VARCHAR(n) or\nNUMERIC(p, s) has no real meaning other than DDL schema documentation only!\n\nThe SQLite INT size can auto grow into 64-bits (like sql: BIGINT) if needed. The REAL type\nis 64-bits size! (unlike many other DB that use REAL for 32-bits and DOUBLE PRECISION for\n64 bits).\n */\n\n-- Test table\ncreate table test(\n  id      integer primary key,\n  ts      text default (datetime('now')),\n  cat     text,\n\n  price   text,\n  qty     int,\n\n  txtdata text,\n  bindata blob,\n\n  distx   real,\n  disty   real\n);\ninsert into test(cat, price, qty) values ('test', 100000.10, 50000),\n                                         ('test', 100000.20, 0),\n                                         ('test', 100000.00, 1),\n                                         ('test', 9977000.3333, 179),\n                                         ('test', 104729.1129, 104729);\ninsert into test(cat, bindata, txtdata) values ('test2', x'CAFEBABE', 'CAFEBABE');\ninsert into test(cat, bindata) values ('test3', randomblob(16));\ninsert into test(cat, bindata) values ('test3', randomblob(16));\ninsert into test(cat, bindata) values ('test3', randomblob(16));\nupdate test set txtdata = hex(bindata) where cat = 'test3';\ninsert into test(cat, distx, disty) values ('test4', random(), random());\ninsert into test(cat, distx, disty) values ('test4', random(), random());\ninsert into test(cat, distx, disty) values ('test4', random(), random());\nselect sum(price) from test where cat = 'test';\nselect * from test order by cat, ts desc;\n")])])])])}),[],!1,null,null,null);e.default=s.exports}}]);