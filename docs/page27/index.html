<!DOCTYPE html>
<html lang="en-us">

  <head>
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <title>
    
      Zemian's Blog &middot; Life in programming world!
    
  </title>

  
  <link rel="canonical" href="http://localhost:4000/page27/">
  

  <link rel="stylesheet" href="http://localhost:4000/public/css/poole.css">
  <link rel="stylesheet" href="http://localhost:4000/public/css/syntax.css">
  <link rel="stylesheet" href="http://localhost:4000/public/css/lanyon.css">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=PT+Serif:400,400italic,700%7CPT+Sans:400">

  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="http://localhost:4000/public/apple-touch-icon-precomposed.png">
  <link rel="shortcut icon" href="http://localhost:4000/public/favicon.ico">

  <link rel="alternate" type="application/rss+xml" title="RSS" href="http://localhost:4000/atom.xml">

  
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
    ga('create', 'UA-135626598-1', 'auto');
    ga('send', 'pageview');
  </script>
  
</head>


  <body>

    <!-- Target for toggling the sidebar `.sidebar-checkbox` is for regular
     styles, `#sidebar-checkbox` for behavior. -->
<input type="checkbox" class="sidebar-checkbox" id="sidebar-checkbox">

<!-- Toggleable sidebar -->
<div class="sidebar" id="sidebar">
  <div class="sidebar-item">
    <p>A weblog on software development.</p>
  </div>

  <nav class="sidebar-nav">
    <a class="sidebar-nav-item active" href="http://localhost:4000/">Home</a>

    

    
    
      
        
      
    
      
        
      
    
      
        
          <a class="sidebar-nav-item" href="http://localhost:4000/about/">About</a>
        
      
    
      
    
      
    
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    

  </nav>

  <div class="sidebar-item">
    <p>
      &copy; 2020. All rights reserved.
    </p>
  </div>
</div>


    <!-- Wrap is the content to shift when toggling the sidebar. We wrap the
         content to avoid any CSS collisions with our real content. -->
    <div class="wrap">
      <div class="masthead">
        <div class="container">
          <h3 class="masthead-title">
            <a href="/" title="Home">Zemian's Blog</a>
            <small>Life in programming world!</small>
          </h3>
        </div>
      </div>

      <div class="container content">
        <div class="posts">
  
  <div class="post">
    <h1 class="post-title">
      <a href="http://localhost:4000/2012/06/17/timemachine-scheduler-tour-part4/">
        TimeMachine Scheduler Tour - Part4
      </a>
    </h1>

    <span class="post-date">17 Jun 2012</span>

    <p>This is part 4 of 7 in a series of articles that will give you a tour of the <a href="https://bitbucket.org/timemachine/scheduler/wiki/Home">TimeMachine Scheduler</a> project. These articles will introduce you to the scheduler, how to load jobs and schedules, and explore some of its advanced features. For the most current and accurate instructions, please visit the ReferenceManual from the project site.</p>

<h2 id="developing-with-timemachine-scheduler-in-java">Developing with TimeMachine scheduler in Java</h2>

<p>The TimeMachine scheduler is written in Java, so the primary language to extend and write custom job task is with Java as well. The obvious benefit of using Java over a Scripting language is it’s speed and IDE tooling when developing.</p>

<p>Recall from previous tour that the scheduler allows you to create a job definition and add any schedules to be run. The actual job execution is provided by a JobTask implementation class name given to the job definition. You may write your own JobTask implementation in Java. After this, then you may write a user service that will register the job task with the scheduler. Through this user service layer, you can also implement event listeners that get invoked when scheduler runs a job, add a schedule, or delete a job def etc.</p>

<p>Before we start, let me show you a Java project setup using Maven3 so that you can use the rest of the tour as demo.</p>

<p>Let start by setup a maven project <code class="language-plaintext highlighter-rouge">scheduler-demo/pom.xml</code> file like this:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;
&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
&lt;groupId&gt;scheduler-demo&lt;/groupId&gt;
&lt;artifactId&gt;scheduler-demo&lt;/artifactId&gt;
&lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt;

&lt;build&gt;
&lt;plugins&gt;
&lt;plugin&gt;
&lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;
&lt;version&gt;2.3.2&lt;/version&gt;
&lt;configuration&gt;
&lt;source&gt;1.6&lt;/source&gt;
&lt;target&gt;1.6&lt;/target&gt;
&lt;/configuration&gt;
&lt;/plugin&gt;
&lt;/plugins&gt;
&lt;/build&gt;

&lt;dependencies&gt;
&lt;dependency&gt;
&lt;groupId&gt;org.bitbucket.timemachine&lt;/groupId&gt;
&lt;artifactId&gt;timemachine-scheduler&lt;/artifactId&gt;
&lt;version&gt;1.1.1&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
&lt;groupId&gt;org.slf4j&lt;/groupId&gt;
&lt;artifactId&gt;slf4j-simple&lt;/artifactId&gt;
&lt;version&gt;1.6.1&lt;/version&gt;
&lt;/dependency&gt;
&lt;/dependencies&gt;
&lt;/project&gt;
</code></pre></div></div>

<p>The timemachine scheduler artifact should already in Maven central, so cd into the scheduler-demo directory and run mvn installshould get your project compiled and installed into your local repository. If you are curious, you may also run mvn dependency:tree to see what are the scheduler dependencies are. You will discover that although the scheduler uses many optional runtime dependencies, the actual compile time dependencies only have few.</p>

<h2 id="writing-jobtask-in-java">Writing JobTask in Java</h2>

<p>Now create a new <code class="language-plaintext highlighter-rouge">src/main/java/schedulerdemo/MyTask.java</code> Java file with following:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>package schedulerdemo;

import timemachine.scheduler.*;

import org.slf4j.*;

public class MyJobTask implements JobTask {

  public static Logger logger = LoggerFactory.getLogger(MyJobTask.class);

  public void run(JobContext jobContext) {

    logger.info("Hello, I am jobTask with " + jobContext.getSchedule());

  }

}
</code></pre></div></div>

<p>The JobTask interface is a very simple one, and the JobContext parameter would give you all the runtime information you need to query and interact with the scheduler. With above, you can immediately run the scheduler server within your maven project setup. But let’s also create a scheduler 
<code class="language-plaintext highlighter-rouge">config/scheduler.properties</code> file that looks like this first:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># config/scheduler.properties
timemachine.scheduler.userservice.jobLoader.class = timemachine.scheduler.userservice.JobLoaderService

JobLoaderService.01myJob.schedulerdemo.MyJobTask = CronSchedule{expression=* * * * * ?}
</code></pre></div></div>

<p>Now you can run the scheduler with your config by using this maven command:</p>

<p>$ mvn exec:java -Dexec.mainClass=timemachine.scheduler.tool.SchedulerServer -Dexec.args=config/scheduler.properties</p>

<h2 id="writing-user-service-in-java">Writing User Service in Java</h2>

<p>Continue with the setup above, you may explore more advanced features of the scheduler. The scheduler API exposes a simple way to let you customize the scheduler. Recall that the scheduler application itself is a container of many system services. The scheduler also has a separate container that holds user services only. To register, you just need to implements the timemachine.scheduler.Service interface.</p>

<p>Try create a new  <code class="language-plaintext highlighter-rouge">src/main/java/schedulerdemo/MyService.java</code> Java file with following:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>package schedulerdemo;

import timemachine.scheduler.*;

import org.slf4j.*;

public class MyService implements Service {

  public static Logger logger = LoggerFactory.getLogger( MyService.class);

  public void init() { logger.info("I am initializing."); }

  public void start() {}
  public void stop() {}
  public void destroy() {}
  public void isInited() { return true; }
  public void isStarted() { return true; }

  public String getName() { return "MyService"; }

}
</code></pre></div></div>

<p>We also provide a convenient <code class="language-plaintext highlighter-rouge">timemachine.scheduler.support.AbstractService</code> class so you may extend it instead. With the abstract class you only need to override the method you interested, and it auto manage the <code class="language-plaintext highlighter-rouge">isInited()</code> and <code class="language-plaintext highlighter-rouge">isStarted()</code> states correctly for you.</p>

<p>With your service ready, you may register it to scheduler with following scheduler config properties appended from earlier:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># config/scheduler.properties

timemachine.scheduler.userservice.jobLoader.class = timemachine.scheduler.userservice.JobLoaderService

JobLoaderService.01myJob.schedulerdemo.MyJobTask = CronSchedule{expression=* * * * * ?}

timemachine.scheduler.userservice.myService.class = schedulerdemo.MyService
</code></pre></div></div>

<p>Now re-start your scheduler again, and you should see your service initialized with log output to verify.</p>

<p>The above service implementation would not do much because you don’t have a reference to the scheduler to setup or do anything. To obtains this, you simply implements timemachine.scheduler.SchedulerListener interface to your existing service class. With that you will have a reference to the scheduler that’s fully initialized already. You may pre-setup jobs or manipulate the scheduler any way you want in your <code class="language-plaintext highlighter-rouge">init()</code> or <code class="language-plaintext highlighter-rouge">start()</code>method once you save the scheduler reference.</p>

<p>Besides the SchedulerListener, there is also JobListener, <code class="language-plaintext highlighter-rouge">ConfigPropsListener</code>, or <code class="language-plaintext highlighter-rouge">CoreServiceListener</code> you may use in the same manner. The JobListener would provide all the events callback methods you would typically want to monitor the scheduler. Since there are many methods to implements, there is a <code class="language-plaintext highlighter-rouge">SchedulerListener</code> adaptor class that’s ready for you to extends as well.</p>

<p>In  this tour, I have introduced and setup a Java Maven based project for you to explore the TimeMachine Scheduler. Go ahead and give these API a try and let us know what you think. If there is any features you are looking for that’s not in current scheduler, then please help file an Issue in the project site. We will be glad to evaluate and look forward to improve the project with you.</p>

<p>End of part 4. You may continue <a href="http://saltnlight5.blogspot.com/2012/06/timemachine-scheduler-tour-part5.html">next tour</a>, or see <a href="http://saltnlight5.blogspot.com/2012/06/timemachine-scheduler-tour-part3.html">previous tour</a>.</p>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="http://localhost:4000/2012/06/13/timemachine-scheduler-tour-part3/">
        TimeMachine Scheduler Tour - Part3
      </a>
    </h1>

    <span class="post-date">13 Jun 2012</span>

    <p>This is part 3 of 7 in a series of articles that will give you a tour of the <a href="https://bitbucket.org/timemachine/scheduler/wiki/Home">TimeMachine Scheduler</a> project. These articles will introduce you to the scheduler, how to load jobs and schedules, and explore some of its advanced features. For the most current and accurate instructions, please visit the ReferenceManual from the project site.</p>

<h2 id="scheduler-data-models">Scheduler Data Models</h2>

<p>The main API entry to TimeMachine Scheduler is the timemachine.scheduler.Scheduler interface. Our default Scheduler implementation is simply a container that hosts many Service’s, and one of the system service is reponsible for storing data. Before I cover more on these system service functionalities, I should introduce to you on the data models that the store service will use.</p>

<p>There four major data models that we persist and managed in the scheduler. They are listed here.</p>

<ul>
  <li>SchedulerData - Represents a logical scheduler. It has an id and a name. A logical scheduler may have one or more physical ScheduleNode.</li>
  <li>SchedulerNode - Represents a physical scheduler instance that runs on a JVM server node. It has an id, name, hostname, IP address, start time, and stop time etc.</li>
  <li>JobDef - A job definition has all the information about a job to be run in a scheduler that belong to a SchedulerData. A JobDef will have an id, an optional name, job task class name, and zero or more Schedule associated with it. A job definition may also contains a map of String properties store data that’s specific for that job task.</li>
  <li>Schedule- A schedule has all the information to tell when and how often a JobDef’s job task will be run. It must exists under a JobDef instance. Besides some common properties, there are 3 specific sub-classes of Schedule that we store separately: CronSchedule, RepeatSchedule, and DateListSchedule. They all share some comon fields such as id, name, startTime, nextRun datetime, missedRunPolicy etc. But they each also have their own additional fields for their specific function as well.</li>
</ul>

<p>Note that the scheduler DataStore system service will auto generate ID value for each instance of model to be store. You can always uniquely identified an model object by it’s ID value. Both JobDef and Schedule’s name is optional and only used to help user perform search by a string name.</p>

<h2 id="how-the-scheduler-works">How the Scheduler Works</h2>

<p>When the scheduler starts, it will first create and initialize a SchedulerNode. Each SchedulerNode must belong to a SchedulerData. If this logical SchedulerData doesn’t exists yet, then it will be auto created, else it will use the existing one. Recall that in our scheduler config file, you have the option to set schedulerName and nodeName, and these two values will uniquecally identify the node instance.</p>

<p>Next the scheduler will initialize and execute the ScheduleRunner system service that will check the DataStore for any job definitions (JobDef) to be run. If they exists, then it checks to see if they have Schedule associated. For each Schedule that belong to a JobDef, it will then check for nextRun datetime. When it’s time to run, the runner service will instanciate the JobDef’s jobTaskClassName object dynamically at runtime, and invoke it’s run() method. That’s when the actual job’s task, or work, begins.</p>

<p>Note that JobDef do not store the task instance directly, but only the class name instead. This is so we can scale and store many job defintions instead of the in-memory objects. The creation of the job task object is at runtime, and you may completely control it by override the JobTaskFactory service.</p>

<p>Before a JobDef’s Schedule is to be run, the scheduler also track and update it’s states. It will go from WAITING to STAGING to RUNNING, and then back to WAITING. Through the Scheduler interface, you may also pause or resume each Schedule individually. If a scheduler is paused, it will not be polled for job task run.</p>

<p>A Schedule may also support a missedRunPolicy that tells scheduler how to handle in case when nextRun has missed the time to run. When it passes the max missed run interval allowed, which is configurable, the scheduler will use this policy value to determine what to do. The default policy is to simply skip to the current date time and continue again. However when this happens, we record and increase this Schedule’s missedRunCount value so you may keep watch of it. Obvously we also track the normal Schedule.runCount as well.</p>

<p>In a nutshell, that’s about how the scheduler works internally with these data models. We have a very flexible API in managing our scheduler system services, and we also allow user to make custom services to be register with the scheduler. All of the system services have well defined interfaces, and you are allow to swap any implementation you wish. For example we provide MemoryDataStore and HiberanteDataStore services that you may choose on how to persist your data. All these are configurable through the simple scheduler properties file. We shall cover some of these settings in future tour.</p>

<p>End of part 3. You may continue <a href="http://saltnlight5.blogspot.com/2012/06/timemachine-scheduler-tour-part4.html">next tour</a>, or see <a href="http://saltnlight5.blogspot.com/2012/06/timemachine-scheduler-tour-part2.html">previous tour</a>.</p>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="http://localhost:4000/2012/06/11/the-hibernatedatastore-preview-is-available/">
        The HibernateDataStore preview is available
      </a>
    </h1>

    <span class="post-date">11 Jun 2012</span>

    <p>One of the reason I delayed the first release of <a href="https://bitbucket.org/timemachine/scheduler/wiki/Home">TimeMachine Scheduler</a> is that I started the HibernateDataStore implementation while polishing the scheduler API. This gave me chance to look ahead on what I need, as this is the major component in the coming 1.1.0 release. The initial Hibernate impl is actually working now! I have made an snapshot of the latest code today, and you may get a preview on how it works. Get the 1.1.0-SNAPSHOT here:
<a href="https://bitbucket.org/timemachine/scheduler/downloads">https://bitbucket.org/timemachine/scheduler/downloads</a></p>

<p>I also started a wiki doc on how to use it here:
<a href="https://bitbucket.org/timemachine/scheduler/wiki/HibernateDataStoreConfig">https://bitbucket.org/timemachine/scheduler/wiki/HibernateDataStoreConfig</a></p>

<p>So give it a try and let me know what you think so far!</p>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="http://localhost:4000/2012/06/10/timemachine-scheduler-tour-part2/">
        TimeMachine Scheduler Tour - Part2
      </a>
    </h1>

    <span class="post-date">10 Jun 2012</span>

    <p>This is part 2 of 7 in a series of articles that will give you a tour of the <a href="https://bitbucket.org/timemachine/scheduler/wiki/Home">TimeMachine Scheduler</a> project. These articles will introduce you to the scheduler, how to load jobs and schedules, and explore some of its advanced features. For the most current and accurate instructions, please visit the ReferenceManual from the project site.</p>

<h2 id="scripting-the-scheduler-with-groovy">Scripting the Scheduler with Groovy</h2>

<p>Scripting language is a great way to extend an application, and with Java 6 or higher it has ScriptingEngine API baked right in. There are many solid JVM based scripting engines available out there today. For example Groovy, Ruby or Jython are just few popular open source ones. The TimeMachine Scheduler embraced the easy and flexibility of scripting. I will be covering some of these features in this tour.</p>

<p>Starting JVM 6 or higher, it already comes with JavaScript engine implementation, and there is no external dependency with this. So TimeMachine has default to use “JavaScript” as scripting engine. You may add any other script engine jars in to the “lib” directory and specify the scriptEngineName parameter to change it.</p>

<p>We have found the <a href="http://groovy.codehaus.org/">Groovy</a> scripting engine to be very productive, and its syntax are very similar to Java language itself, but yet very concise and expressive. So we decided to make TimeMachine distribution zip file pre-packaged the Groovy jars for user convenient. (Note that Groovy is only an optional dependency for TimeMachine scheduler itself, and we have properly set our maven pom.xml as such.)</p>

<p>All the demo code in this tour will use Groovy. You are free to choose other engine if you want to explore it further.</p>

<h2 id="the-scriptingservice">The ScriptingService</h2>

<p>You may initialize the scheduler along with a script file and let it execute and prepare jobs or anything you would need before the scheduler is started. You will start by create a config/scheduler.properties file like this:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>timemachine.scheduler.userservice.scriptingService.class = timemachine.scheduler.userservice.ScriptingService

ScriptingService.scriptEngineName = Groovy

ScriptingService.initScript = config/myscript.groovy
</code></pre></div></div>

<p>In your config/myscript.groovy file, you may try this:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>logger.info("Hello World!")

logger.info("I have access to " + scheduler)
</code></pre></div></div>

<p>Now you can fire off the scheduler:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ bin/scheduler.sh config/scheduler.properties
</code></pre></div></div>

<p>You should see the scheduler started with the hello world message printed on log output.</p>

<h2 id="the-scheduler-api">The Scheduler API</h2>

<p>From above  you can see that we give you two variables to play with in the script. The logger is simple one, and you probably don’t do anything more than logging info message. The more interesting one is the scheduler variable. This variable would have full access to the scheduler; it  is an instance of  <a href="http://tmschedulersite-zdeng.rhcloud.com/scheduler-site/timemachine-scheduler/target/site-deploy/timemachine-scheduler/apidocs/timemachine/scheduler/Scheduler.html">timemachine.scheduler.Scheduler</a> class. Let’s use this variable to create a cron job in the following Groovy initScript:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>import timemachine.scheduler.*
import timemachine.scheduler.schedule.*
import timemachine.scheduler.jobtask.*

jobDef = new JobDef()

jobDef.setJobTaskClass(LoggerJobTask.class)

schedule = new CronSchedule()
schedule.setExpression("* * * * * ?")

jobDef.addSchedule(schedule)

scheduler.schedule(jobDef)
</code></pre></div></div>

<p>The scheduler API is pretty self explanatory, but let me be more explicit to help along. We imported all the packages and classes that we need first, then we created a job definition object. We told it what task to do and how often to do it. We created 3 schedules/jobs that will run the task. We finally scheduled and stored this job definition to the scheduler. These jobs will run according to the schedule (every second) as soon as your scheduler starts. You may verify through the output log.</p>

<p>For convenience sake, we also provide factory classes that can make above program even shorter.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>import timemachine.scheduler.*
jobDef = JobDefs.loggerJobDef()
jobDef.add(Schedules.cron("* * * * * ?"))
scheduler.schedule(jobDef)

## Schedule Types

Besides the CronSchedule, we also have RepeatSchedule and DateListSchedule schedule types. We have created a nice factory methods in Schedules that return one of these schedule. For example, we may create a minutely repeat schedule and an explicit date list schedules in the initScript like this: 

import timemachine.scheduler.*
jobDef = JobDefs.osCommandJobDef("cmd.exe /c echo 'Hello World.'")
jobDef.addSchedule(Schedules.minutely(5))
jobDef.addSchedule(Schedules.datelist(*[Schedules.datetime("01/01/2013 08:00:00"), Schedules.datetime("01/01/2014 08:00:00")]))

scheduler.schedule(jobDef)
</code></pre></div></div>

<p>In above, we have scheduled one job definition with two schedules to run. First one runs every 5 mins, and the second one runs twice on an explicit given dates.</p>

<p>Note: The asterisk in front of left bracket is needed due to Groovy syntax on passing an list object into Java’s wildcard variable argument.</p>

<h2 id="jobtask-types">JobTask Types</h2>

<p>Besides the LoggerJobTask and OsCommandJobTask built-in JobTask you have seen above, we also have a powerful ScriptingJobTask that let you build a job task in Groovy code! This means you may add a new job without even compiling Java code! Here is an example of Groovy initScript script that will create a new “scripting” job.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>import timemachine.scheduler.*
jobDef = JobDefs.groovyJobDef('''
file= new File("/tmp/counter.data")
if (!file.exists())
  num = 1
else
  num  = file.text.toInteger() + 1
logger.info("Incrementing counter $num in $file")
file.write(num)
''')
jobDef.addSchedule(Schedules.secondly(1)) // run every second.

scheduler.schedule(jobDef)
</code></pre></div></div>

<p>In above example, we created a job that runs every second. The job task will increment a counter in a file and re-save it every time the job runs.</p>

<h2 id="pretty-groovy-">Pretty Groovy …</h2>

<p>There you go. Above is your first custom job in TimeMachine Scheduler! The Groovy language is very similar to Java in syntax, yet minus all the noises, so it’s very productive. Groovy also access and integrate with existing <a href="http://docs.oracle.com/javase/6/docs/api/">Java API</a> seamlessly, so you may access and control the scheduler with easy.</p>

<p>Interested? Go and <a href="https://bitbucket.org/timemachine/scheduler/downloads">download</a>the scheduler today and give it a try!</p>

<p>End of part 2. You may continue <a href="http://saltnlight5.blogspot.com/2012/06/timemachine-scheduler-tour-part3.html">next tour</a>, or see <a href="http://saltnlight5.blogspot.com/2012/06/timemachine-scheduler-tour-part1.html">previous tour</a>.</p>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="http://localhost:4000/2012/06/06/timemachine-scheduler-tour-part1/">
        TimeMachine Scheduler Tour - Part1
      </a>
    </h1>

    <span class="post-date">06 Jun 2012</span>

    <p>This is part 1 of 7 in a series of articles that will give you a tour of the <a href="https://bitbucket.org/timemachine/scheduler/wiki/Home">TimeMachine Scheduler</a> project. These articles will introduce you to the scheduler, how to load jobs and schedules, and explore some of its advanced features. For the most current and accurate instructions, please visit the ReferenceManual from the project site.</p>

<h2 id="what-is-timemachine-scheduler">What is TimeMachine Scheduler</h2>

<p>TimeMachine is a Java scheduler that can scale and run high volume of jobs with many different types of schedules, such as repeating on fixed interval or based on CRON expressions. The scheduler may control the job executions with thread pools, and it can persist job data into different storage. Users may use the built-in scheduler server with easy configuration file, or developers may use it as a library to extend the scheduler and write custom jobs, schedules, or user services.</p>

<h2 id="getting-started">Getting started</h2>
<p>First step is to download the latest scheduler distribution and uznip it into your system. Then fire up the scheduler with some sample jobs.</p>

<p>We will be printing commands and its output running on a MacOSX terminal. If you have a Microsoft Windows, then running a Cygwin terminal would also work. Or if you are Linux user then you just use a Terminal.</p>

<p>(NOTE: If you don’t feel like downloading software, you may try our <a href="http://tmschedulerdemo-zdeng.rhcloud.com/scheduler-demo/job-list">online demo</a>. You may edit the scheduler configuration directly in a web form, and it will restart the scheduler immediately upon Save.)</p>

<p>If you have downloaded the zip file under an “apps” directory in your HOME folder, then follow these steps to get a scheduler instance running:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ cd $HOME/apps
$ unzip timemachine-scheduler-1.1.1.zip
$ cd timemachine-scheduler-1.1.1
$ bin/scheduler.sh config/scheduler.properties
</code></pre></div></div>

<p>You should see some log output on the terminal console screen like this</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>22:57:08 main INFO| TimeScheduler system services initialized: [
  scheduler: SchedulerData[id=1, name=TimeMachineScheduler],
  schedulerNode: SchedulerNode[nodeId=1, name=ZEMIANs-iMac.local, ip=192.168.1.130],
  configProps: config/scheduler.properties,
  dataStore: MemoryDataStore[name=386981384],
  scheduleRunner: PollingScheduleRunner[name=1186906970],
  classLoader: SimpleClassLoaderService[name=1363910379],
  jobTaskFactory: SimpleJobTaskFactory[name=621450213],
  jobTaskPoolNameResolver: SimpleJobTaskPoolNameResolver[name=1945442111],
  jobTaskThreadPool: DynamicThreadPool[name=jobTaskThreadPool.DEFAULT],
]
22:57:08 main INFO| Scheduler[id=1, nodeId=1, nodeIp=192.168.1.130] initialized. Version=1.1.1.062720122255
22:57:08 main INFO| Scheduler[id=1, nodeId=1, nodeIp=192.168.1.130] started.
</code></pre></div></div>

<p>You may hit CTRL+C to exit the scheduler. The above config/scheduler.properties configuration file would not do much other than load an empty scheduler. To see more in action, try the <code class="language-plaintext highlighter-rouge">config/crontab.properties</code> config instead. It should look something like this:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>timemachine.scheduler.userservice.crontabService.class = timemachine.scheduler.userservice.CrontabService
CrontabService.01 = 0 0 * * * ?        | sh -c echo "Hourly task begins."
CrontabService.02 = 0/5 * * * * ?      | sh -c echo "Heart beat."
CrontabService.03 = 0 0/5 * * * ?      | sh -c echo "Five minutes job."
CrontabService.04 = 0 0 12 * JAN,JUN ? | sh -c echo "We should clean up every 6 months."
CrontabService.05 = 0 0 8 ? * 1-5      | sh -c echo "Every workday at 8AM."
</code></pre></div></div>

<p>The above configuration will make the scheduler to work similar to the Unix crontab service. It let you input a <a href="http://tmschedulersite-zdeng.rhcloud.com/scheduler-site/timemachine-scheduler/target/site-deploy/timemachine-scheduler/apidocs/index.html">CRON expression</a>, and then follow by a OS executable command to be run. Go ahead, try to replace the “echo” command in the config file with any other commands that you know of (ping for example), and then restart the scheduler. Our default log settings should display all the external command’s output as it execute.</p>

<p>There are few more configuration entries that you may add to customize the scheduler. Here are few we will examine closely. For example:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>timemachine.scheduler.schedulerName = TimeMachineScheduler
timemachine.scheduler.nodeName = ZEMIANs-iMac.local
timemachine.scheduler.dataStore.class = timemachine.scheduler.service.MemoryDataStore
timemachine.scheduler.jobTaskThreadPool.DEFAULT.class = timemachine.scheduler.service.DynamicThreadPool
timemachine.scheduler.jobTaskThreadPool.DEFAULT.minSize = 0
timemachine.scheduler.jobTaskThreadPool.DEFAULT.maxSize = 4
timemachine.scheduler.jobTaskThreadPool.DEFAULT.threadNamePrefix = ${timemachine.scheduler.schedulerName}-JobTask-Thread-
</code></pre></div></div>

<p>You are free to change the scheduler name. Both the schedulerName and nodeName together will form a unique name for this instance of scheduler. These are printed as you start the scheduler so you can verify and identify them.</p>

<p>We allow you to switch to different datastore, and we are using a in-memory store in this case. We also  provide a HibernateDataStore that you may use to persist the data into a database of your choice. We will cover this later in the tour, but for now we will focus on the simple in-memory store.</p>

<p>One benefit of using our scheduler over a typical Unix cron is that you may control the thread pool to execute your jobs. You see the last few lines of configuration that defined a dynamic thread pool (it will not create the threads if your scheduler is idle without jobs to run.) You may change the min and max pool size, and you may even change the thread name. You may see the thread name in any JDK management tool such as jvisualvm.</p>

<p>Notice one feature of our scheduler configuration, it allow you to substitude an existing value with <code class="language-plaintext highlighter-rouge">${key}</code> format! We use this to set our thread name that reuse the value you already set as schedulerName.</p>

<p>End of part 1. You may continue <a href="http://saltnlight5.blogspot.com/2012/06/timemachine-scheduler-tour-part2.html">next tour</a>.</p>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="http://localhost:4000/2012/05/28/intro-to-timemachine-scheduler-1-0-0/">
        Intro to TimeMachine Scheduler 1.0.0
      </a>
    </h1>

    <span class="post-date">28 May 2012</span>

    <p>Hello developers,</p>

<p>I am happy to annouce the first release of TimeMachine Scheduler is available for you to download here:</p>

<p><a href="https://bitbucket.org/timemachine/scheduler/downloads">https://bitbucket.org/timemachine/scheduler/downloads</a></p>

<p>Our first release of the scheduler comes with many features ready to use already. I will briefly describe 
them here.</p>

<p>Out of the box, you can use it as an Unix Crontab system replacement. Since it’s Java based, you can run it in Windows as well.You may pass a config file that loos like this and kick of the scheduler server to execute any OS commands or scripts you wish:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    timemachine.scheduler.userservice.crontab.class = timemachine.scheduler.userservice.CrontabService
    CrontabService.01 = 0 0 * * * ?        | sh -c echo "Hourly task begins."
    CrontabService.02 = 0/5 * * * * ?      | sh -c echo "Heart beat."
</code></pre></div></div>

<p>The scheduler has flexible configuration and allow full control on the job executions settings. For example you may configure the job task thread pool to be dynamic, so that it only creates threads when there are jobs to be run, else the pool size will shrink. Or you can even create multiple thread pools and match your jobs, effectively separated them in running Queues.</p>

<p>Besides using external native commands, the scheduler also let you write your own job tasks. You can write new job task in either Java, JavaScript or Groovy scripting language. We package the optional Groovy engine in our distribution so it can be more convenient to write your own job, without even the need to re-compile source files, nor restart the scheduler instance!</p>

<p>The scheduler comes with 3 built-in Schedule implementations that you may use to configure how often a job task runs. There is a RepeatSchedule that runs job in a fixed interval manner; a CronSchedule that uses a Unix CRON expression; and we have the DateListSchedule that simply let you use any arbituray dates to run.</p>

<p>For this initial release, we only provide a in-memory data store implementation for persisting job and scheduling data. Our goal is to support other type of data store persistance such as using a database in the future. But even with this release, we’ve designed our API to support multiple scheduler nodes that run under a single logic scheduler. You can even do this with our in-memory data store!</p>

<p>The TimeMachien Scheduler is designed to run with high volumes of jobs, and to give you flexible 
control on time scheduling, threads executions and data storage. You can learn more on our project site <a href="https://bitbucket.org/timemachine/scheduler/wiki">https://bitbucket.org/timemachine/scheduler/wiki</a></p>

<p>Enjoy,</p>

<p>Zemian Deng</p>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="http://localhost:4000/2012/05/11/changing-oracle-xe-apex-webapp-port/">
        Changing Oracle XE apex webapp port
      </a>
    </h1>

    <span class="post-date">11 May 2012</span>

    <p>If you use Oracle XE for development, then you know it has a simple web interface through http://localhost:8080/apex. Now port 8080 is a common port used by Tomcat server, so letting Oracle XE permanently have taken it is not convenient. But you can change it like this:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> sql&gt; select dbms_xdb.gethttpport from dual;
 sql&gt; exec dbms_xdb.sethttpport('8081');
 sql&gt; commit;

 bash&gt; open http://localhost:8081/apex
</code></pre></div></div>

<p>Also, if you ever deleted the HR sample database on the XE installation, you can restore it like this:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> bash&gt; cd /c/oraclexe/app/oracle/product/10.2.0/server/demo/schema/human_resources
 bash&gt; sqlplus system &lt; hr_main.sql
</code></pre></div></div>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="http://localhost:4000/2012/04/28/timemachine-scheduler-demo/">
        TimeMachine Scheduler Demo
      </a>
    </h1>

    <span class="post-date">28 Apr 2012</span>

    <p>I just put out a scheduler demo live on <a href="https://bitbucket.org/timemachine/scheduler/wiki/SchedulerWebDemo">https://bitbucket.org/timemachine/scheduler/wiki/SchedulerWebDemo</a></p>

<p>You can poke around the scheduler using Groovy scripting on this quick demo. The bad thing is that everyone in public has access and can add/delete and modify the scheduler! But it’s a good way for you to explore around. Check it out and let me know what you think!</p>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="http://localhost:4000/2012/04/25/tryout-timemachine-scheduler/">
        Tryout TimeMachine Scheduler
      </a>
    </h1>

    <span class="post-date">25 Apr 2012</span>

    <p>There are few updates with TimeMachine Scheduler project:</p>

<ol>
  <li>The project has a new home: 
<a href="https://bitbucket.org/timemachine/scheduler/wiki/Home">https://bitbucket.org/timemachine/scheduler/wiki/Home</a></li>
  <li>I’ve been updating with SNAPSHOT downloads frequently lately, and the zip file binary distribution is fairly stable now. We are close to making the first official release.</li>
  <li>I’ve been working hard to update the ReferenceManual under wiki so users can get started and use it effectively.</li>
</ol>

<p>Give the project a try and let me know what you think!</p>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="http://localhost:4000/2012/04/11/inspecting-your-oracle-database/">
        Inspecting your Oracle database
      </a>
    </h1>

    <span class="post-date">11 Apr 2012</span>

    <p>Some quick tips on how to inspect what you have in your Oracle database.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>-- show all schemas
select distinct owner from dba_segments where owner in
     (select username from dba_users where default_tablespace not in ('SYSTEM','SYSAUX'));

-- show all tables from a schema/owner
select * from all_tables where owner = 'HR';

-- show table description
desc HR.EMPLOYEES;

-- show all users
select * from all_users;
select username, * from dba_users;


-- See who is taking up a DB lock
select c.*, b.* from v$lock a, dba_locks b, v$session c 
  where a.id1 = b.lock_id1 and b.session_id = c.sid

-- See internal SQL id
select * from v$sql

-- See Oracle latches:
select * from v$latch

-- See Library Cache of SGA (System Global Area) like buffer cache size:
select * from v$sgastat

-- See tx locks (TX) and DML locks (TM):
select * from v$lock where type in ('TX', 'TM')
select * from dba_locks where lock_type in ('Transaction', 'DML')
</code></pre></div></div>


  </div>
  
</div>

<div class="pagination">
  
    <a class="pagination-item older" href="http://localhost:4000/page28">Older</a>
  
  
    
      <a class="pagination-item newer" href="http://localhost:4000/page26">Newer</a>
    
  
</div>

      </div>
    </div>

    <label for="sidebar-checkbox" class="sidebar-toggle"></label>

    <script src='/public/js/script.js'></script>
  </body>
</html>
